<div class="video-player-container">
  <div class="video-section">
    <% if @video.video_file.attached? %>
      <div class="question-indicator" id="question-indicator" style="display: none;">å•é¡Œã‚ã‚Šï¼</div>
      
      <!-- ãƒ‡ãƒãƒƒã‚°æƒ…å ±ãƒ‘ãƒãƒ« -->
      <div class="debug-panel" id="debug-panel" style="display: none;">
        <div class="debug-header">
          ç›®ç·šè¿½è·¡ãƒ‡ãƒãƒƒã‚°æƒ…å ±
          <button class="btn btn-sm btn-outline-light ms-2" id="toggle-camera-preview">ã‚«ãƒ¡ãƒ©</button>
        </div>
        
        <!-- ã‚¿ãƒ–ãƒŠãƒ“ã‚²ãƒ¼ã‚·ãƒ§ãƒ³ -->
        <div class="debug-tabs">
          <button class="debug-tab-btn active" onclick="showDebugTab('info')">åŸºæœ¬æƒ…å ±</button>
          <button class="debug-tab-btn" onclick="showDebugTab('factors')">ã‚¹ã‚³ã‚¢è¦å› </button>
          <button class="debug-tab-btn" onclick="showDebugTab('settings')">ã‚¹ã‚³ã‚¢è¨­å®š</button>
          <button class="debug-tab-btn" onclick="showDebugTab('timestamp')">ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—</button>
        </div>
        
        <!-- åŸºæœ¬æƒ…å ±ã‚¿ãƒ– -->
        <div id="debug-tab-info" class="debug-tab-content">
          <div>æ¤œå‡ºæ–¹å¼: <span id="detection-method">åˆæœŸåŒ–ä¸­...</span></div>
          <div>é¡”æ¤œå‡º: <span id="face-detected">-</span></div>
          <div>ç›®ç·šæ–¹å‘X: <span id="gaze-x">-</span></div>
          <div>ç›®ç·šæ–¹å‘Y: <span id="gaze-y">-</span></div>
          <div>ç›®ç·šæ–¹å‘: <span id="gaze-direction">-</span></div>
          <div>æ­£é¢å‘ãå‰²åˆ: <span id="front-facing">-</span>%</div>
          <div>æœ€å¾Œã®å‹•ã: <span id="last-movement">-</span>ç§’å‰</div>
          <div>ãƒ¡ãƒ¢å…¥åŠ›å›æ•°: <span id="note-inputs">0</span></div>
          
          <!-- çœ¼çƒãƒ‡ãƒ¼ã‚¿è©³ç´° -->
          <div class="eyeball-details" style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.1); border-radius: 4px;">
            <div style="font-weight: bold; color: #4fc3f7; margin-bottom: 5px;">ğŸ” çœ¼çƒè¿½è·¡ãƒ‡ãƒ¼ã‚¿</div>
            <pre id="eyeball-details" style="font-size: 9px; line-height: 1.2; margin: 0; white-space: pre-wrap;">çœ¼çƒãƒ‡ãƒ¼ã‚¿å¾…æ©Ÿä¸­...</pre>
          </div>
          
          <!-- ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ -->
          <div class="camera-preview" id="camera-preview" style="display: none;">
            <div class="camera-container" style="position: relative; display: inline-block;">
              <video id="debug-camera" width="320" height="240" autoplay muted></video>
              <canvas id="gaze-overlay-canvas" width="320" height="240" 
                      style="position: absolute; top: 0; left: 0; pointer-events: none;"></canvas>
            </div>
          </div>
          
          <!-- é›†ä¸­åº¦å¤‰å‹•ãƒ­ã‚° -->
          <div class="concentration-log">
            <div class="log-header">é›†ä¸­åº¦å¤‰å‹•ãƒ­ã‚°</div>
            <div class="log-content" id="concentration-log"></div>
          </div>
        </div>
        
        <!-- ã‚¹ã‚³ã‚¢è¦å› ã‚¿ãƒ– -->
        <div id="debug-tab-factors" class="debug-tab-content" style="display: none;">
          <div class="factors-header">ã‚¹ã‚³ã‚¢å¤‰å‹•ã‚¤ãƒ™ãƒ³ãƒˆèª¬æ˜</div>
          <div id="score-factors" class="score-factors">
            <div class="factor-category">
              <h7 class="category-title">ğŸ“¹ ã‚«ãƒ¡ãƒ©é–¢é€£</h7>
              <div class="factor-item neutral">
                <div class="factor-header">é¡”æœªæ¤œå‡º (-2ç‚¹)</div>
                <div class="factor-detail">ã‚«ãƒ¡ãƒ©ã«é¡”ãŒæ˜ ã£ã¦ã„ãªã„å ´åˆã«æ¸›ç‚¹ã•ã‚Œã¾ã™</div>
              </div>
            </div>
            
            <div class="factor-category">
              <h7 class="category-title">ğŸ‘€ ç›®ç·šãƒ»æ³¨è¦–</h7>
              <div class="factor-item positive">
                <div class="factor-header">é›†ä¸­æ³¨è¦– (+0.5ç‚¹)</div>
                <div class="factor-detail">ç”»é¢ä¸­å¤®ã‚’æ³¨è¦–ã—ã¦ã„ã‚‹å ´åˆã«åŠ ç‚¹ã•ã‚Œã¾ã™</div>
              </div>
              <div class="factor-item positive">
                <div class="factor-header">å•é¡Œç¢ºèª (+5ç‚¹)</div>
                <div class="factor-detail">å•é¡Œè¡¨ç¤ºå¾Œ3ç§’ä»¥å†…ã«å³å‘ãã®è¦–ç·šé€Ÿåº¦ãŒ10px/sä»¥ä¸Šã«ãªã£ãŸå ´åˆã«åŠ ç‚¹ã•ã‚Œã¾ã™</div>
              </div>
              <div class="factor-item negative">
                <div class="factor-header">ç›®ç·šåœæ­¢ (-20ç‚¹ã¾ã§)</div>
                <div class="factor-detail">10ç§’ä»¥ä¸Šç›®ç·šã®å‹•ããŒãªã„å ´åˆã«æ¸›ç‚¹ã•ã‚Œã¾ã™</div>
              </div>
            </div>
            
            <div class="factor-category">
              <h7 class="category-title">âš¡ åå¿œé€Ÿåº¦</h7>
              <div class="factor-item negative">
                <div class="factor-header">å›ç­”é…å»¶ (-15ç‚¹ã¾ã§)</div>
                <div class="factor-detail">å•é¡Œè¡¨ç¤ºã‹ã‚‰30ç§’ä»¥ä¸ŠçµŒéã—ã¦å›ç­”ã—ãŸå ´åˆã«æ¸›ç‚¹ã•ã‚Œã¾ã™</div>
              </div>
              <div class="factor-item positive">
                <div class="factor-header">ç´ æ—©ã„å›ç­” (+3ç‚¹)</div>
                <div class="factor-detail">å•é¡Œè¡¨ç¤ºã‹ã‚‰5ç§’ä»¥å†…ã«å›ç­”ã—ãŸå ´åˆã«åŠ ç‚¹ã•ã‚Œã¾ã™</div>
              </div>
            </div>
            
            <div class="factor-category">
              <h7 class="category-title">ğŸ“ ãƒ¡ãƒ¢æ´»å‹•</h7>
              <div class="factor-item positive">
                <div class="factor-header">ãƒ¡ãƒ¢å…¥åŠ› (+3ç‚¹/å›)</div>
                <div class="factor-detail">æ–°ã—ã„ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã™ã‚‹ãŸã³ã«åŠ ç‚¹ã•ã‚Œã¾ã™</div>
              </div>
            </div>
          </div>
        </div>
        
        <!-- ã‚¹ã‚³ã‚¢è¨­å®šã‚¿ãƒ– -->
        <div id="debug-tab-settings" class="debug-tab-content" style="display: none;">
          <div class="settings-header">ã‚¹ã‚³ã‚¢èª¿æ•´è¨­å®š</div>
          <div class="settings-content">
            
            <!-- æ¸›ç‚¹è¨­å®š -->
            <div class="settings-category">
              <h7 class="settings-category-title">æ¸›ç‚¹è¨­å®š</h7>
              
              <div class="setting-item">
                <label for="face-not-detected-penalty">é¡”æœªæ¤œå‡ºæ™‚ã®æ¸›ç‚¹:</label>
                <input type="number" id="face-not-detected-penalty" value="2" min="0" max="10" step="0.1">
                <span class="setting-unit">ç‚¹</span>
              </div>
              
              <div class="setting-item">
                <label for="movement-stop-penalty">ç›®ç·šåœæ­¢æ™‚ã®æ¸›ç‚¹:</label>
                <input type="number" id="movement-stop-penalty" value="1" min="0" max="5" step="0.1">
                <span class="setting-unit">ç‚¹/ç§’</span>
              </div>
              
              <div class="setting-item">
                <label for="response-delay-penalty">å›ç­”é…å»¶æ™‚ã®æ¸›ç‚¹:</label>
                <input type="number" id="response-delay-penalty" value="1" min="0" max="5" step="0.1">
                <span class="setting-unit">ç‚¹/ç§’</span>
              </div>
            </div>
            
            <!-- åŠ ç‚¹è¨­å®š -->
            <div class="settings-category">
              <h7 class="settings-category-title">åŠ ç‚¹è¨­å®š</h7>
              
              <div class="setting-item">
                <label for="center-gaze-bonus">ä¸­å¤®æ³¨è¦–æ™‚ã®åŠ ç‚¹:</label>
                <input type="number" id="center-gaze-bonus" value="0.5" min="0" max="5" step="0.1">
                <span class="setting-unit">ç‚¹</span>
              </div>
              
              <div class="setting-item">
                <label for="question-confirm-bonus">å•é¡Œç¢ºèªæ™‚ã®åŠ ç‚¹:</label>
                <input type="number" id="question-confirm-bonus" value="5" min="0" max="20" step="0.5">
                <span class="setting-unit">ç‚¹</span>
              </div>
              
              <div class="setting-item">
                <label for="quick-response-bonus">ç´ æ—©ã„å›ç­”æ™‚ã®åŠ ç‚¹:</label>
                <input type="number" id="quick-response-bonus" value="3" min="0" max="10" step="0.5">
                <span class="setting-unit">ç‚¹</span>
              </div>
              
              <div class="setting-item">
                <label for="note-input-bonus">ãƒ¡ãƒ¢å…¥åŠ›æ™‚ã®åŠ ç‚¹:</label>
                <input type="number" id="note-input-bonus" value="3" min="0" max="10" step="0.5">
                <span class="setting-unit">ç‚¹</span>
              </div>
              
              <div class="setting-item">
                <label for="front-facing-bonus">æ­£é¢æ³¨è¦–æ™‚ã®åŠ ç‚¹:</label>
                <input type="number" id="front-facing-bonus" value="1" min="0" max="5" step="0.1">
                <span class="setting-unit">ç‚¹</span>
              </div>
            </div>
            
            <!-- æ™‚é–“è¨­å®š -->
            <div class="settings-category">
              <h7 class="settings-category-title">æ™‚é–“é–“éš”è¨­å®š</h7>
              
              <div class="setting-item">
                <label for="movement-stop-threshold">ç›®ç·šåœæ­¢åˆ¤å®šæ™‚é–“:</label>
                <input type="number" id="movement-stop-threshold" value="10" min="1" max="60" step="1">
                <span class="setting-unit">ç§’</span>
              </div>
              
              <div class="setting-item">
                <label for="response-delay-threshold">å›ç­”é…å»¶åˆ¤å®šæ™‚é–“:</label>
                <input type="number" id="response-delay-threshold" value="30" min="5" max="120" step="1">
                <span class="setting-unit">ç§’</span>
              </div>
              
              <div class="setting-item">
                <label for="quick-response-threshold">ç´ æ—©ã„å›ç­”åˆ¤å®šæ™‚é–“:</label>
                <input type="number" id="quick-response-threshold" value="5" min="1" max="30" step="0.5">
                <span class="setting-unit">ç§’</span>
              </div>
              
              <div class="setting-item">
                <label for="front-facing-interval">æ­£é¢æ³¨è¦–åŠ ç‚¹é–“éš”:</label>
                <input type="number" id="front-facing-interval" value="5000" min="100" max="10000" step="100">
                <span class="setting-unit">ãƒŸãƒªç§’</span>
              </div>
              
              <div class="setting-item">
                <label for="center-gaze-interval">é›†ä¸­æ³¨è¦–åŠ ç‚¹é–“éš”:</label>
                <input type="number" id="center-gaze-interval" value="3000" min="100" max="10000" step="100">
                <span class="setting-unit">ãƒŸãƒªç§’</span>
              </div>
            </div>
            
            <!-- ãã®ä»–è¨­å®š -->
            <div class="settings-category">
              <h7 class="settings-category-title">ãã®ä»–è¨­å®š</h7>
              
              <div class="setting-item">
                <label for="movement-detection-threshold">ç›®ç·šå‹•ãæ¤œå‡ºé–¾å€¤:</label>
                <input type="number" id="movement-detection-threshold" value="16" min="1" max="50" step="1">
                <span class="setting-unit">ãƒ”ã‚¯ã‚»ãƒ«</span>
              </div>
              
              <div class="setting-item">
                <label for="center-gaze-threshold">ä¸­å¤®æ³¨è¦–åˆ¤å®šç¯„å›²:</label>
                <input type="number" id="center-gaze-threshold" value="15" min="5" max="50" step="1">
                <span class="setting-unit">ãƒ”ã‚¯ã‚»ãƒ«</span>
              </div>
              
              <div class="setting-item">
                <label for="gaze-velocity-threshold">å•é¡Œç¢ºèªåˆ¤å®šé€Ÿåº¦:</label>
                <input type="number" id="gaze-velocity-threshold" value="10" min="1" max="50" step="1">
                <span class="setting-unit">px/s</span>
              </div>
            </div>
            
            <!-- è¨­å®šæ“ä½œãƒœã‚¿ãƒ³ -->
            <div class="settings-actions">
              <button class="btn btn-primary btn-sm" id="apply-settings">è¨­å®šã‚’é©ç”¨</button>
              <button class="btn btn-secondary btn-sm" id="reset-settings">ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™</button>
              <button class="btn btn-info btn-sm" id="export-settings">è¨­å®šã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
              <button class="btn btn-success btn-sm" id="import-settings">è¨­å®šã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ</button>
              <input type="file" id="import-file" accept=".json" style="display: none;">
            </div>
          </div>
        </div>
        
        <!-- ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚¿ãƒ– -->
        <div id="debug-tab-timestamp" class="debug-tab-content" style="display: none;">
          <div class="timestamp-header">
            <span>å­¦ç¿’è¡Œå‹•ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—</span>
            <div class="timestamp-controls">
              <button class="btn btn-sm btn-success" id="export-timestamp">ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ</button>
              <button class="btn btn-sm btn-primary" id="save-to-server">ã‚µãƒ¼ãƒãƒ¼ä¿å­˜</button>
              <button class="btn btn-sm btn-info" id="clear-timestamp">ã‚¯ãƒªã‚¢</button>
            </div>
          </div>
          
          <div class="timestamp-stats">
            <div class="stat-item">
              <span class="stat-label">ã‚»ãƒƒã‚·ãƒ§ãƒ³æ™‚é–“:</span>
              <span id="session-duration">0:00</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">å‹•ç”»æ™‚åˆ»:</span>
              <span id="current-video-time">0:00</span>
            </div>
            <div class="stat-item">
              <span class="stat-label">ã‚¤ãƒ™ãƒ³ãƒˆæ•°:</span>
              <span id="event-count">0</span>
            </div>
          </div>
          
          <div class="timestamp-log" id="timestamp-log">
            <div class="timestamp-entry">
              <div class="timestamp-header">
                <span class="timestamp-time">ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹å¾…æ©Ÿä¸­...</span>
              </div>
            </div>
          </div>
        </div>
      </div>
      
      <video id="video-player" controls>
        <source src="<%= url_for(@video.video_file) %>" type="<%= @video.video_file.content_type %>">
        Your browser does not support the video tag.
      </video>
    <% else %>
      <div class="no-video">
        <p>å‹•ç”»ãŒåˆ©ç”¨ã§ãã¾ã›ã‚“</p>
      </div>
    <% end %>
    
    <div class="video-info">
      <h1><%= @video.title %></h1>
      <div class="video-actions">
        <% if @video.pdf_file.attached? %>
          <a href="<%= url_for(@video.pdf_file) %>" target="_blank" class="btn btn-primary">è¬›ç¾©è³‡æ–™ã‚’é–‹ã</a>
        <% end %>
        <%= link_to 'æˆ»ã‚‹', root_path, class: "btn btn-secondary" %>
        
        <!-- é›†ä¸­åº¦ã‚²ãƒ¼ã‚¸ -->
        <div class="concentration-gauge" id="concentration-gauge">
          <div class="gauge-header">
            <span>é›†ä¸­åº¦</span>
            <button class="btn btn-sm btn-outline-light" id="toggle-debug-info">ãƒ‡ãƒãƒƒã‚°</button>
          </div>
          <div class="gauge-bar">
            <div class="gauge-level gauge-green" id="gauge-green"></div>
            <div class="gauge-level gauge-yellow" id="gauge-yellow"></div>
            <div class="gauge-level gauge-orange" id="gauge-orange"></div>
            <div class="gauge-level gauge-red" id="gauge-red"></div>
          </div>
          <div class="gauge-score" id="gauge-score">100%</div>
        </div>
      </div>
    </div>
  </div>
  
  <div class="side-panel">
    <div class="question-section" id="question-section">
      <div class="section-header">
        <h3>å•é¡Œ</h3>
      </div>
      
      <div class="question-content" id="question-container">
        <div class="waiting-message" id="waiting-message">
          <p>å‹•ç”»ã‚’å†ç”Ÿã™ã‚‹ã¨ã€å•é¡ŒãŒè¡¨ç¤ºã•ã‚Œã¾ã™</p>
          <% if @questions.any? %>
            <p><strong>è¨­å®šã•ã‚Œã¦ã„ã‚‹å•é¡Œæ•°: <%= @questions.count %></strong></p>
          <% else %>
            <p><strong>ã“ã®å‹•ç”»ã«ã¯å•é¡ŒãŒã‚ã‚Šã¾ã›ã‚“</strong></p>
          <% end %>
        </div>
        
        <div class="question-display" id="question-display" style="display: none;">
          <div class="question-text" id="question-text"></div>
          
          <div class="question-form" id="true-false-form" style="display: none;">
            <div class="options">
              <label class="option-label">
                <input type="radio" name="tf-answer" value="â—‹"> â—‹
              </label>
              <label class="option-label">
                <input type="radio" name="tf-answer" value="Ã—"> Ã—
              </label>
            </div>
            <button class="btn btn-primary" id="tf-submit">å›ç­”ã™ã‚‹</button>
          </div>
          
          <div class="question-form" id="multiple-choice-form" style="display: none;">
            <div class="options" id="mc-options"></div>
            <button class="btn btn-primary" id="mc-submit">å›ç­”ã™ã‚‹</button>
          </div>
          
          <div class="question-form" id="free-response-form" style="display: none;">
            <textarea id="free-response-answer" rows="3" class="form-control" placeholder="å›ç­”ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„"></textarea>
            <button class="btn btn-primary mt-2" id="fr-submit">å›ç­”ã™ã‚‹</button>
          </div>
          
          <div class="result-message" id="result-message" style="display: none;"></div>
        </div>
      </div>
    </div>
    
    <div class="notes-section">
      <div class="section-header">
        <h3>ãƒ¡ãƒ¢</h3>
        <button class="btn btn-sm btn-primary" id="save-note-btn">ä¿å­˜</button>
      </div>
      
      <div class="notes-content">
        <textarea id="note-textarea" rows="10" class="form-control" placeholder="ã“ã“ã«ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã§ãã¾ã™..."></textarea>
        
        <div class="saved-notes" id="saved-notes">
          <% if @notes.any? %>
            <h4>ä¿å­˜ã—ãŸãƒ¡ãƒ¢</h4>
            <ul class="notes-list">
              <% @notes.each do |note| %>
                <li class="note-item">
                  <div class="note-time"><%= format_time_position(note.time_position) %></div>
                  <div class="note-text"><%= note.content %></div>
                </li>
              <% end %>
            </ul>
          <% end %>
        </div>
      </div>
    </div>
  </div>
</div>

<style>
  body {
    margin: 0;
    padding: 0;
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Helvetica, Arial, sans-serif;
    background-color: #f8f9fa;
  }
  
  .video-player-container {
    display: flex;
    min-height: 100vh;
    background-color: #000;
  }
  
  .video-section {
    flex: 3;
    display: flex;
    flex-direction: column;
    overflow: hidden;
    position: relative;
  }
  
  .question-indicator {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(255, 193, 7, 0.9);
    color: #000;
    padding: 5px 10px;
    border-radius: 4px;
    font-weight: bold;
    z-index: 101;
    display: none;
    animation: fadeIn 0.5s;
  }
  
  @keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
  }
  
  /* é›†ä¸­åº¦ã‚²ãƒ¼ã‚¸ */
  .concentration-gauge {
    display: inline-flex;
    flex-direction: column;
    align-items: center;
    background-color: rgba(0, 0, 0, 0.8);
    color: white;
    padding: 10px;
    border-radius: 8px;
    margin-left: 10px;
    min-width: 100px;
  }
  
  .gauge-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 8px;
    font-size: 12px;
    font-weight: bold;
    width: 100%;
  }
  
  .gauge-bar {
    display: flex;
    flex-direction: column;
    height: 60px;
    width: 20px;
    border: 1px solid #555;
    border-radius: 4px;
    overflow: hidden;
    margin-bottom: 5px;
  }
  
  .gauge-level {
    flex: 1;
    transition: opacity 0.3s ease;
    opacity: 0.3;
  }
  
  .gauge-level.active {
    opacity: 1;
  }
  
  .gauge-green { background-color: #28a745; }
  .gauge-yellow { background-color: #ffc107; }
  .gauge-orange { background-color: #fd7e14; }
  .gauge-red { background-color: #dc3545; }
  
  .gauge-score {
    text-align: center;
    font-size: 11px;
    font-weight: bold;
  }
  
  /* ãƒ‡ãƒãƒƒã‚°ãƒ‘ãƒãƒ« */
  .debug-panel {
    position: absolute;
    top: 10px;
    right: 10px;
    background-color: rgba(0, 0, 0, 0.95);
    color: white;
    padding: 10px;
    border-radius: 8px;
    z-index: 99;
    max-width: 350px;
  }
  
  .debug-tabs {
    display: flex;
    margin-bottom: 10px;
    border-bottom: 1px solid #444;
  }
  
  .debug-tab-btn {
    background: none;
    border: none;
    color: #ccc;
    padding: 8px 12px;
    cursor: pointer;
    border-bottom: 2px solid transparent;
    transition: all 0.3s ease;
  }
  
  .debug-tab-btn.active {
    color: white;
    border-bottom-color: #007bff;
  }
  
  .debug-tab-btn:hover {
    color: white;
    background-color: rgba(255, 255, 255, 0.1);
  }
  
  .debug-tab-content {
    animation: fadeIn 0.3s ease;
  }
  
  .score-factors {
    max-height: 200px;
    overflow-y: auto;
    font-size: 12px;
  }
  
  .factor-item {
    background-color: rgba(255, 255, 255, 0.1);
    margin: 5px 0;
    padding: 8px;
    border-radius: 4px;
    border-left: 3px solid #007bff;
  }
  
  .factor-item.positive {
    border-left-color: #28a745;
  }
  
  .factor-item.negative {
    border-left-color: #dc3545;
  }
  
  .factor-item.neutral {
    border-left-color: #6c757d;
  }
  
  .factor-header {
    font-weight: bold;
    margin-bottom: 3px;
  }
  
  .factor-detail {
    font-size: 11px;
    color: #ccc;
  }
  
  .factor-category {
    margin-bottom: 15px;
  }
  
  .category-title {
    font-size: 13px;
    font-weight: bold;
    color: #fff;
    margin-bottom: 8px;
    display: block;
    border-bottom: 1px solid #444;
    padding-bottom: 3px;
  }
  
  .factors-header {
    font-weight: bold;
    margin-bottom: 8px;
    border-bottom: 1px solid #555;
    padding-bottom: 4px;
  }
  
  .debug-header {
    font-weight: bold;
    margin-bottom: 8px;
    border-bottom: 1px solid #555;
    padding-bottom: 4px;
    display: flex;
    justify-content: space-between;
    align-items: center;
  }
  
  .debug-content div {
    margin-bottom: 3px;
  }
  
  .camera-preview {
    margin-top: 10px;
    border-top: 1px solid #555;
    padding-top: 10px;
  }
  
  /* è¨­å®šã‚¿ãƒ–ã®ã‚¹ã‚¿ã‚¤ãƒ« */
  .settings-content {
    max-height: 400px;
    overflow-y: auto;
    font-size: 12px;
  }
  
  .settings-category {
    margin-bottom: 15px;
    padding: 8px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
  }
  
  .settings-category-title {
    font-size: 13px;
    font-weight: bold;
    color: #4fc3f7;
    margin-bottom: 8px;
    display: block;
    border-bottom: 1px solid #444;
    padding-bottom: 3px;
  }
  
  .setting-item {
    display: flex;
    align-items: center;
    justify-content: space-between;
    margin-bottom: 8px;
    padding: 4px 0;
  }
  
  .setting-item label {
    flex: 1;
    font-size: 11px;
    color: #ddd;
    margin-bottom: 0;
  }
  
  .setting-item input {
    width: 60px;
    padding: 2px 4px;
    font-size: 11px;
    background-color: rgba(255, 255, 255, 0.1);
    border: 1px solid #555;
    border-radius: 3px;
    color: #fff;
    margin: 0 5px;
  }
  
  .setting-unit {
    font-size: 10px;
    color: #aaa;
    min-width: 40px;
    text-align: left;
  }
  
  .settings-actions {
    margin-top: 15px;
    padding-top: 10px;
    border-top: 1px solid #555;
    display: flex;
    flex-wrap: wrap;
    gap: 5px;
  }
  
  .settings-actions .btn {
    font-size: 10px;
    padding: 4px 8px;
  }
  
  .settings-header {
    font-weight: bold;
    margin-bottom: 10px;
    color: #4fc3f7;
    border-bottom: 1px solid #555;
    padding-bottom: 4px;
  }

  /* ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚¿ãƒ–ã®ã‚¹ã‚¿ã‚¤ãƒ« */
  .timestamp-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-weight: bold;
    margin-bottom: 10px;
    color: #4fc3f7;
    border-bottom: 1px solid #555;
    padding-bottom: 4px;
  }
  
  .timestamp-controls {
    display: flex;
    gap: 5px;
  }
  
  .timestamp-controls .btn {
    font-size: 10px;
    padding: 3px 6px;
  }
  
  .timestamp-stats {
    display: flex;
    justify-content: space-around;
    margin-bottom: 10px;
    padding: 8px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
  }
  
  .stat-item {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 11px;
  }
  
  .stat-label {
    color: #aaa;
    margin-bottom: 2px;
  }
  
  .timestamp-log {
    max-height: 300px;
    overflow-y: auto;
    font-size: 11px;
  }
  
  .timestamp-entry {
    margin-bottom: 8px;
    padding: 6px;
    background-color: rgba(255, 255, 255, 0.05);
    border-radius: 4px;
    border-left: 3px solid #007bff;
  }
  
  .timestamp-entry.score-event {
    border-left-color: #28a745;
  }
  
  .timestamp-entry.video-event {
    border-left-color: #ffc107;
  }
  
  .timestamp-entry.interaction-event {
    border-left-color: #17a2b8;
  }
  
  .timestamp-entry .timestamp-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: 4px;
    padding-bottom: 2px;
    border-bottom: 1px solid rgba(255, 255, 255, 0.1);
  }
  
  .timestamp-time {
    font-size: 10px;
    color: #ccc;
  }
  
  .timestamp-type {
    font-size: 10px;
    padding: 2px 6px;
    background-color: rgba(0, 123, 255, 0.3);
    border-radius: 3px;
    color: #fff;
  }
  
  .concentration-score {
    font-size: 10px;
    font-weight: bold;
    color: #4fc3f7;
  }
  
  .timestamp-body {
    font-size: 10px;
  }
  
  .timestamp-description {
    color: #ddd;
    margin-bottom: 3px;
  }
  
  .timestamp-times {
    display: flex;
    gap: 10px;
    color: #aaa;
    font-size: 9px;
  }

  .camera-preview video,
  .camera-preview canvas {
    border: 1px solid #555;
    border-radius: 4px;
    margin-bottom: 5px;
    transform: scaleX(-1); /* å·¦å³åè»¢ */
  }
  
  .concentration-log {
    margin-top: 10px;
    border-top: 1px solid #555;
    padding-top: 10px;
  }
  
  .log-header {
    font-weight: bold;
    margin-bottom: 5px;
  }
  
  .log-content {
    max-height: 150px;
    overflow-y: auto;
    font-size: 10px;
    line-height: 1.2;
  }
  
  .log-entry {
    margin-bottom: 2px;
    padding: 2px 4px;
    background-color: rgba(255, 255, 255, 0.1);
    border-radius: 2px;
    cursor: pointer;
    transition: background-color 0.2s ease;
  }
  
  .log-entry:hover {
    background-color: rgba(255, 255, 255, 0.2);
  }
  
  .log-entry.positive {
    background-color: rgba(40, 167, 69, 0.3);
  }
  
  .log-entry.negative {
    background-color: rgba(220, 53, 69, 0.3);
  }
  
  .log-entry.neutral {
    background-color: rgba(108, 117, 125, 0.3);
  }
  
  .log-main {
    font-weight: bold;
  }
  
  .log-detail {
    margin-top: 3px;
    padding-top: 3px;
    border-top: 1px solid rgba(255, 255, 255, 0.2);
    font-size: 9px;
    line-height: 1.3;
    color: rgba(255, 255, 255, 0.8);
  }
  
  #video-player {
    width: 100%;
    max-height: calc(100vh - 100px);
  }
  
  .video-info {
    padding: 15px;
    background-color: #111;
    color: #fff;
  }
  
  .video-info h1 {
    font-size: 20px;
    margin: 0 0 10px 0;
  }
  
  .video-actions {
    display: flex;
    justify-content: flex-start;
    align-items: center;
    gap: 10px;
  }
  
  .side-panel {
    flex: 2;
    display: flex;
    flex-direction: column;
    background-color: #f8f9fa;
    border-left: 1px solid #dee2e6;
    overflow: hidden;
    max-width: 450px;
  }
  
  .question-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    border-bottom: 1px solid #dee2e6;
    overflow: hidden;
  }
  
  .notes-section {
    flex: 1;
    display: flex;
    flex-direction: column;
    overflow: hidden;
  }
  
  .section-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 10px 15px;
    background-color: #e9ecef;
    border-bottom: 1px solid #dee2e6;
  }
  
  .section-header h3 {
    margin: 0;
    font-size: 18px;
  }
  
  .question-content, .notes-content {
    flex: 1;
    padding: 15px;
    overflow-y: auto;
  }
  
  .waiting-message {
    text-align: center;
    padding: 50px 20px;
    color: #6c757d;
  }
  
  .question-display {
    background-color: #fff;
    border-radius: 5px;
    padding: 20px;
    box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
  }
  
  .question-text {
    font-size: 18px;
    margin-bottom: 20px;
    line-height: 1.5;
  }
  
  .question-timestamp {
    font-size: 14px;
    color: #6c757d;
    margin-bottom: 8px;
    font-weight: bold;
  }
  
  .options {
    margin-bottom: 15px;
  }
  
  .option-label {
    display: block;
    margin-bottom: 10px;
    padding: 10px;
    background-color: #f0f0f0;
    border-radius: 4px;
    cursor: pointer;
    transition: background-color 0.2s;
  }
  
  .option-label:hover {
    background-color: #e0e0e0;
  }
  
  .option-label input {
    margin-right: 10px;
  }
  
  .result-message {
    margin-top: 20px;
    padding: 15px;
    border-radius: 4px;
  }
  
  .result-message.correct {
    background-color: #d4edda;
    color: #155724;
    border: 1px solid #c3e6cb;
  }
  
  .result-message.incorrect {
    background-color: #f8d7da;
    color: #721c24;
    border: 1px solid #f5c6cb;
  }
  
  #note-textarea {
    resize: none;
    border: 1px solid #ced4da;
    border-radius: 4px;
    width: 100%;
  }
  
  .saved-notes {
    margin-top: 20px;
  }
  
  .notes-list {
    list-style: none;
    padding: 0;
    margin: 0;
  }
  
  .note-item {
    background-color: #fff;
    border-radius: 4px;
    padding: 10px 15px;
    margin-bottom: 10px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
  }
  
  .note-time {
    font-size: 12px;
    color: #6c757d;
    margin-bottom: 5px;
  }
  
  .note-text {
    white-space: pre-wrap;
  }
  
  .no-video {
    display: flex;
    align-items: center;
    justify-content: center;
    height: 400px;
    color: #fff;
    background-color: #343a40;
  }
  
  .form-control {
    display: block;
    width: 100%;
    padding: .375rem .75rem;
    font-size: 1rem;
    line-height: 1.5;
    color: #495057;
    background-color: #fff;
    background-clip: padding-box;
    border: 1px solid #ced4da;
    border-radius: .25rem;
    transition: border-color .15s ease-in-out,box-shadow .15s ease-in-out;
  }
  
  .btn {
    display: inline-block;
    font-weight: 400;
    text-align: center;
    white-space: nowrap;
    vertical-align: middle;
    user-select: none;
    border: 1px solid transparent;
    padding: .375rem .75rem;
    font-size: 1rem;
    line-height: 1.5;
    border-radius: .25rem;
    transition: color .15s ease-in-out,background-color .15s ease-in-out,border-color .15s ease-in-out,box-shadow .15s ease-in-out;
    cursor: pointer;
  }
  
  .btn-sm {
    padding: .25rem .5rem;
    font-size: .875rem;
    line-height: 1.5;
    border-radius: .2rem;
  }
  
  .btn-primary {
    color: #fff;
    background-color: #007bff;
    border-color: #007bff;
  }
  
  .btn-secondary {
    color: #fff;
    background-color: #6c757d;
    border-color: #6c757d;
  }
  
  .mt-2 {
    margin-top: .5rem;
  }
</style>

<!-- MediaPipe Face Mesh ãƒ©ã‚¤ãƒ–ãƒ©ãƒª -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/face_mesh.js" crossorigin="anonymous"></script>

<script>
document.addEventListener('DOMContentLoaded', function() {
  const videoPlayer = document.getElementById('video-player');
  
  // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°ã‚’è¿½åŠ 
  window.addEventListener('error', function(event) {
    console.error('Caught global error:', event.error);
  });
  
  // é›†ä¸­åº¦ç®¡ç†ã‚¯ãƒ©ã‚¹
  class ConcentrationTracker {
    constructor() {
      this.score = 20;
      this.faceDetected = false;
      this.gazeX = 0;
      this.gazeY = 0;
      this.frontFacingRatio = 100;
      this.lastMovementTime = Date.now();
      this.noteInputs = 0;
      this.lastNoteCount = 0;
      this.responseStartTime = null;
      this.questionDisplayTime = null;
      this.responseProcessed = false; // åå¿œæ™‚é–“å‡¦ç†æ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’è¿½åŠ 
      this.questionConfirmed = false; // å•é¡Œç¢ºèªæ¸ˆã¿ãƒ•ãƒ©ã‚°ã‚’è¿½åŠ 
      this.gazeOverlayInterval = null; // è¦–ç·šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤æ›´æ–°ã‚¤ãƒ³ã‚¿ãƒ¼ãƒãƒ«
      
      // ã‚¹ã‚³ã‚¢èª¿æ•´è¨­å®š
      this.scoreSettings = {
        // æ¸›ç‚¹ç³»
        faceNotDetectedPenalty: 2,      // é¡”æœªæ¤œå‡ºæ™‚ã®æ¸›ç‚¹
        movementStopPenalty: 1,         // ç›®ç·šåœæ­¢æ™‚ã®æ¸›ç‚¹ï¼ˆç§’ã‚ãŸã‚Šï¼‰
        responseDelayPenalty: 1,        // å›ç­”é…å»¶æ™‚ã®æ¸›ç‚¹ï¼ˆç§’ã‚ãŸã‚Šï¼‰
        
        // åŠ ç‚¹ç³»
        centerGazeBonus: 0,           // ä¸­å¤®æ³¨è¦–æ™‚ã®åŠ ç‚¹
        // é›†ä¸­æ³¨è¦–: å­¦ç¿’è€…ãŒç”»é¢ã®ä¸­å¤®ï¼ˆå‹•ç”»ã‚„ã‚³ãƒ³ãƒ†ãƒ³ãƒ„ãŒã‚ã‚‹å ´æ‰€ï¼‰ã«è¦–ç·šã‚’å‘ã‘ã¦ã„ã‚‹çŠ¶æ…‹
        questionConfirmBonus: 5,        // å•é¡Œç¢ºèªæ™‚ã®åŠ ç‚¹
        quickResponseBonus: 3,          // ç´ æ—©ã„å›ç­”æ™‚ã®åŠ ç‚¹
        noteInputBonus: 3,              // ãƒ¡ãƒ¢å…¥åŠ›æ™‚ã®åŠ ç‚¹
        frontFacingBonus: 1,            // æ­£é¢æ³¨è¦–æ™‚ã®åŠ ç‚¹ã€€
        // æ­£é¢æ³¨è¦–: å­¦ç¿’è€…ãŒç”»é¢ã‹ã‚‰é›¢ã‚ŒãŸã‚Šã€æ¨ªã‚’å‘ã„ãŸã‚Šã›ãšã€æ­£é¢ã‚’å‘ã„ã¦å­¦ç¿’ã—ã¦ã„ã‚‹çŠ¶æ…‹
        
        // æ™‚é–“é–“éš”è¨­å®š
        movementStopThreshold: 10,      // ç›®ç·šåœæ­¢ã¨åˆ¤å®šã™ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰
        responseDelayThreshold: 30,     // å›ç­”é…å»¶ã¨åˆ¤å®šã™ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰
        quickResponseThreshold: 5,      // ç´ æ—©ã„å›ç­”ã¨åˆ¤å®šã™ã‚‹æ™‚é–“ï¼ˆç§’ï¼‰
        questionConfirmWindow: 3,       // å•é¡Œç¢ºèªåˆ¤å®šã®æ™‚é–“çª“ï¼ˆç§’ï¼‰
        frontFacingInterval: 5000,      // æ­£é¢æ³¨è¦–åŠ ç‚¹ã®é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰
        centerGazeInterval: 5000,       // é›†ä¸­æ³¨è¦–åŠ ç‚¹ã®é–“éš”ï¼ˆãƒŸãƒªç§’ï¼‰
        
        // ãã®ä»–è¨­å®š
        movementDetectionThreshold: 10, // ç›®ç·šå‹•ãæ¤œå‡ºã®é–¾å€¤ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
        gazeVelocityThreshold: 10,      // å•é¡Œç¢ºèªã¨åˆ¤å®šã™ã‚‹è¦–ç·šé€Ÿåº¦ï¼ˆpx/sï¼‰
        centerGazeThreshold: 15         // ä¸­å¤®æ³¨è¦–ã¨åˆ¤å®šã™ã‚‹ç¯„å›²ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
      };
      
      // æ­£é¢æ³¨è¦–ã®æœ€å¾Œã®åŠ ç‚¹æ™‚åˆ»
      this.lastFrontFacingBonus = 0;
      // é›†ä¸­æ³¨è¦–ã®æœ€å¾Œã®åŠ ç‚¹æ™‚åˆ»
      this.lastCenterGazeBonus = 0;
      
      // ãƒãƒƒãƒä¿å­˜ç”¨ã®ç®¡ç†å¤‰æ•°
      this.lastSaveTime = Date.now();
      this.lastSaveEventCount = 0;
      this.pendingEvents = 0;
      this.saveInProgress = false;
      
      // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨˜éŒ²ã‚·ã‚¹ãƒ†ãƒ 
      this.timestampLog = [];
      this.sessionStartTime = Date.now();
      this.videoElement = null;
      this.lastVideoTime = 0;
      this.videoState = 'stopped'; // stopped, playing, paused
      this.lastPlaybackRate = 1.0;
      
      // çœ¼çƒå‹•ãã®å¤‰åŒ–é‡è¿½è·¡
      this.previousGaze = { x: 0, y: 0, timestamp: Date.now() };
      this.gazeVelocity = { x: 0, y: 0 }; // ãƒ”ã‚¯ã‚»ãƒ«/ç§’
      this.gazeAcceleration = { x: 0, y: 0 }; // ãƒ”ã‚¯ã‚»ãƒ«/ç§’Â²
      this.previousVelocity = { x: 0, y: 0, timestamp: Date.now() };
      this.eyeMovementHistory = []; // æœ€è¿‘ã®å‹•ãã®å±¥æ­´ï¼ˆ5ãƒ•ãƒ¬ãƒ¼ãƒ åˆ†ï¼‰
      
      // è¦–ç·šãƒ‡ãƒ¼ã‚¿ã®ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ç”¨
      this.gazeRawHistory = []; // ç”Ÿã®è¦–ç·šãƒ‡ãƒ¼ã‚¿å±¥æ­´ï¼ˆ10ãƒ•ãƒ¬ãƒ¼ãƒ åˆ†ï¼‰
      this.gazeSmoothed = { x: 0, y: 0 }; // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®è¦–ç·šãƒ‡ãƒ¼ã‚¿
      this.smoothingWindowSize = 8; // ç§»å‹•å¹³å‡ã®ã‚¦ã‚£ãƒ³ãƒ‰ã‚¦ã‚µã‚¤ã‚º
      this.noiseThreshold = 3; // ãƒã‚¤ã‚ºé™¤å»ã®é–¾å€¤ï¼ˆãƒ”ã‚¯ã‚»ãƒ«ï¼‰
      this.lastValidGaze = { x: 0, y: 0, timestamp: Date.now() }; // æœ€å¾Œã®æœ‰åŠ¹ãªè¦–ç·šãƒ‡ãƒ¼ã‚¿
      
      // é¡”ã®å‘ãã®è¿½è·¡
      this.headPoseX = 0; // é¡”ã®æ°´å¹³æ–¹å‘ã®å‘ãï¼ˆ-50 to 50ï¼‰
      this.headPoseY = 0; // é¡”ã®å‚ç›´æ–¹å‘ã®å‘ãï¼ˆ-50 to 50ï¼‰
      this.previousHeadPose = { x: 0, y: 0, timestamp: Date.now() };
      this.headPoseVelocity = { x: 0, y: 0 }; // é¡”ã®å‘ãã®å¤‰åŒ–é€Ÿåº¦
      
      // MediaPipeé–¢é€£ã®åˆæœŸåŒ–
      this.faceMesh = null;
      this.camera = null;
      this.useMediaPipe = true; // MediaPipeã‚’ä½¿ç”¨ã™ã‚‹ã‹ã®ãƒ•ãƒ©ã‚°
      this.mediaPipeInitialized = false;
      
      this.initializeCamera();
      this.initializeGauge();
      this.initializeDebugPanel();
      this.initializeVideoTracking();
      this.startTracking();
      
      // æœªä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚§ãƒƒã‚¯ã¨å¾©æ—§
      this.checkPendingSessionData();
      
      // åˆæœŸåŒ–å®Œäº†å¾Œã«å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒ†ã‚¹ãƒˆç”¨ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚’è¿½åŠ 
      setTimeout(() => {
        this.addTimestamp('test_init', 'ã‚·ã‚¹ãƒ†ãƒ åˆæœŸåŒ–å®Œäº†');
        console.log('ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚·ã‚¹ãƒ†ãƒ ã®ãƒ†ã‚¹ãƒˆåˆæœŸåŒ–å®Œäº†');
        
        // åˆæœŸåŒ–å¾Œã•ã‚‰ã«å°‘ã—å¾…ã£ã¦ã‹ã‚‰ãƒ†ã‚¹ãƒˆä¿å­˜
        setTimeout(() => {
          console.log('åˆæœŸåŒ–å¾Œã®ãƒ†ã‚¹ãƒˆä¿å­˜ã‚’å®Ÿè¡Œã—ã¾ã™');
          this.saveSessionToServer();
        }, 3000);
      }, 1000);
      
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°ã¨ã—ã¦ã‚¿ãƒ–åˆ‡ã‚Šæ›¿ãˆã‚’ç™»éŒ²
      window.showDebugTab = this.showDebugTab.bind(this);
      
      // ãƒ‡ãƒãƒƒã‚°ç”¨ã®ã‚°ãƒ­ãƒ¼ãƒãƒ«é–¢æ•°
      window.debugSaveSession = () => {
        console.log('æ‰‹å‹•ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¿å­˜ã‚’å®Ÿè¡Œã—ã¾ã™...');
        console.log('ç¾åœ¨ã®timestampLog:', this.timestampLog);
        console.log('ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹æ™‚åˆ»:', new Date(this.sessionStartTime));
        console.log('ãƒ¦ãƒ¼ã‚¶ãƒ¼èªè¨¼çŠ¶æ…‹:', <%= user_signed_in? ? 'true' : 'false' %>);
        console.log('ç¾åœ¨ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ID:', <%= current_user&.id || 'null' %>);
        this.saveSessionToServer();
      };
      
      // ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¢ã‚¯ã‚»ã‚¹ç”¨ã«ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹ã‚’ç™»éŒ²
      window.concentrationTracker = this;
      
      // ãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†è¨˜éŒ²ï¼ˆè¤‡æ•°ã®ã‚¤ãƒ™ãƒ³ãƒˆã§ç¢ºå®Ÿã«ä¿å­˜ï¼‰
      this.setupExitHandlers();
      
      // åŠ¹ç‡çš„ãªãƒãƒƒãƒä¿å­˜ï¼ˆæ¡ä»¶ãƒ™ãƒ¼ã‚¹ï¼‰
      this.setupBatchSaving();
    }
    
    async initializeCamera() {
      try {
        console.log('ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–é–‹å§‹...');
        
        const stream = await navigator.mediaDevices.getUserMedia({ 
          video: { 
            width: 640, 
            height: 480,
            facingMode: 'user'
          } 
        });
        
        // éš ã—videoè¦ç´ ã‚’ä½œæˆã—ã¦ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’è¡¨ç¤º
        this.cameraVideo = document.createElement('video');
        this.cameraVideo.srcObject = stream;
        this.cameraVideo.autoplay = true;
        this.cameraVideo.muted = true;
        this.cameraVideo.style.display = 'none';
        document.body.appendChild(this.cameraVideo);
        
        // Canvasè¦ç´ ã‚’ä½œæˆã—ã¦é¡”æ¤œå‡ºç”¨ã«ä½¿ç”¨
        this.canvas = document.createElement('canvas');
        this.canvas.width = 640;
        this.canvas.height = 480;
        this.ctx = this.canvas.getContext('2d');
        
        // MediaPipeã®åˆæœŸåŒ–
        await this.initializeMediaPipe();
        
        console.log('ã‚«ãƒ¡ãƒ©åˆæœŸåŒ–å®Œäº†');
      } catch (error) {
        console.error('ã‚«ãƒ¡ãƒ©ã‚¢ã‚¯ã‚»ã‚¹ã‚¨ãƒ©ãƒ¼:', error);
        console.log('MediaPipeã‚’ç„¡åŠ¹ã«ã—ã¦ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ã§ç¶šè¡Œ');
        this.useMediaPipe = false;
      }
    }
    
    async initializeMediaPipe() {
      try {
        console.log('MediaPipeåˆæœŸåŒ–é–‹å§‹...');
        
        // MediaPipeãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
        if (typeof FaceMesh === 'undefined') {
          throw new Error('MediaPipe FaceMeshãƒ©ã‚¤ãƒ–ãƒ©ãƒªãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“');
        }
        
        // FaceMeshãƒ¢ãƒ‡ãƒ«ã®åˆæœŸåŒ–
        this.faceMesh = new FaceMesh({
          locateFile: (file) => {
            return `https://cdn.jsdelivr.net/npm/@mediapipe/face_mesh/${file}`;
          }
        });
        
        // FaceMeshã®è¨­å®š
        this.faceMesh.setOptions({
          maxNumFaces: 1,
          refineLandmarks: true, // ã‚ˆã‚Šè©³ç´°ãªãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯æ¤œå‡ºã‚’æœ‰åŠ¹
          minDetectionConfidence: 0.7, // æ¤œå‡ºç²¾åº¦ã‚’å‘ä¸Š
          minTrackingConfidence: 0.5
        });
        
        // çµæœå‡¦ç†ã®ã‚³ãƒ¼ãƒ«ãƒãƒƒã‚¯è¨­å®š
        this.faceMesh.onResults(this.onFaceMeshResults.bind(this));
        
        // ã‚«ãƒ¡ãƒ©ã‹ã‚‰ã®æ˜ åƒé€ä¿¡é–‹å§‹
        if (typeof Camera !== 'undefined') {
          this.camera = new Camera(this.cameraVideo, {
            onFrame: async () => {
              if (this.faceMesh && this.mediaPipeInitialized) {
                await this.faceMesh.send({ image: this.cameraVideo });
              }
            },
            width: 640,
            height: 480
          });
          
          await this.camera.start();
        }
        
        this.mediaPipeInitialized = true;
        console.log('MediaPipeåˆæœŸåŒ–å®Œäº†');
        
      } catch (error) {
        console.error('MediaPipeåˆæœŸåŒ–ã‚¨ãƒ©ãƒ¼:', error);
        this.useMediaPipe = false;
        console.log('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ã«åˆ‡ã‚Šæ›¿ãˆ');
      }
    }
    
    initializeGauge() {
      this.gaugeElements = {
        green: document.getElementById('gauge-green'),
        yellow: document.getElementById('gauge-yellow'),
        orange: document.getElementById('gauge-orange'),
        red: document.getElementById('gauge-red'),
        score: document.getElementById('gauge-score')
      };
    }
    
    initializeDebugPanel() {
      const toggleButton = document.getElementById('toggle-debug-info');
      const debugPanel = document.getElementById('debug-panel');
      
      toggleButton.addEventListener('click', () => {
        debugPanel.style.display = debugPanel.style.display === 'none' ? 'block' : 'none';
      });
      
      // ã‚«ãƒ¡ãƒ©ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼æ©Ÿèƒ½
      const toggleCameraButton = document.getElementById('toggle-camera-preview');
      const cameraPreview = document.getElementById('camera-preview');
      const debugCamera = document.getElementById('debug-camera');
      
      toggleCameraButton.addEventListener('click', () => {
        if (cameraPreview.style.display === 'none') {
          cameraPreview.style.display = 'block';
          // ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’ãƒ‡ãƒãƒƒã‚°ç”¨videoã«è¡¨ç¤º
          if (this.cameraVideo && this.cameraVideo.srcObject) {
            debugCamera.srcObject = this.cameraVideo.srcObject;
          }
          // è¦–ç·šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’æ›´æ–°é–‹å§‹
          this.startGazeOverlayUpdates();
        } else {
          cameraPreview.style.display = 'none';
          // è¦–ç·šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚’åœæ­¢
          this.stopGazeOverlayUpdates();
          
          // ã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’ã‚¯ãƒªã‚¢
          const overlay = document.getElementById('gazeOverlay');
          if (overlay) {
            const ctx = overlay.getContext('2d');
            ctx.clearRect(0, 0, overlay.width, overlay.height);
          }
        }
      });
      
      this.debugElements = {
        detectionMethod: document.getElementById('detection-method'),
        faceDetected: document.getElementById('face-detected'),
        gazeX: document.getElementById('gaze-x'),
        gazeY: document.getElementById('gaze-y'),
        gazeDirection: document.getElementById('gaze-direction'),
        frontFacing: document.getElementById('front-facing'),
        lastMovement: document.getElementById('last-movement'),
        noteInputs: document.getElementById('note-inputs'),
        eyeballDetails: document.getElementById('eyeball-details')
      };
      
      // ãƒ­ã‚°æ©Ÿèƒ½ã®åˆæœŸåŒ–
      this.logElement = document.getElementById('concentration-log');
      this.logs = [];
      
      // è¨­å®šãƒ‘ãƒãƒ«ã®åˆæœŸåŒ–
      this.initializeSettingsPanel();
      
      // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãƒ‘ãƒãƒ«ã®åˆæœŸåŒ–
      this.initializeTimestampPanel();
    }
    
    onFaceMeshResults(results) {
      try {
        if (results.multiFaceLandmarks && results.multiFaceLandmarks.length > 0) {
          this.faceDetected = true;
          const landmarks = results.multiFaceLandmarks[0];
          
          // è¦–ç·šæ–¹å‘ã‚’è¨ˆç®—
          this.calculateGazeFromLandmarks(landmarks);
          
        } else {
          this.faceDetected = false;
          // é¡”ãŒæ¤œå‡ºã•ã‚Œãªã„å ´åˆã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
          this.gazeX = 0;
          this.gazeY = 0;
        }
        
        // æ­£é¢å‘ãå‰²åˆã®æ›´æ–°
        this.updateFrontFacingRatio();
        
      } catch (error) {
        console.error('FaceMeshçµæœå‡¦ç†ã‚¨ãƒ©ãƒ¼:', error);
        this.faceDetected = false;
      }
    }
    
    calculateGazeFromLandmarks(landmarks) {
      try {
        // çœ¼çƒã®è©³ç´°ãªãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ã‚’å–å¾—
        const leftEyeData = this.getDetailedEyeData(landmarks, 'left');
        const rightEyeData = this.getDetailedEyeData(landmarks, 'right');
        
        // ä¸¡ç›®ã®ãƒ‡ãƒ¼ã‚¿ãŒæœ‰åŠ¹ãªå ´åˆã®ã¿å‡¦ç†
        if (leftEyeData.isValid && rightEyeData.isValid) {
          // ä¸¡ç›®ã®çœ¼çƒä½ç½®ã®å¹³å‡ã‚’è¨ˆç®—
          const avgPupilX = (leftEyeData.pupilRatio.x + rightEyeData.pupilRatio.x) / 2;
          const avgPupilY = (leftEyeData.pupilRatio.y + rightEyeData.pupilRatio.y) / 2;
          
          // çœ¼çƒã®å‹•ãã‚’è¦–ç·šæ–¹å‘ã«å¤‰æ›ï¼ˆ-1 to 1ã®ç¯„å›²ï¼‰
          // ã‚«ãƒ¡ãƒ©æ˜ åƒãŒå·¦å³åè»¢ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€Xåº§æ¨™ã‚‚åè»¢
          // å·¦å³ã®å‹•ã: è² ã®å€¤ãŒå³ã€æ­£ã®å€¤ãŒå·¦ï¼ˆåè»¢ï¼‰
          const normalizedGazeX = -((avgPupilX - 0.5) * 2);
          // ä¸Šä¸‹ã®å‹•ã: è² ã®å€¤ãŒä¸Šã€æ­£ã®å€¤ãŒä¸‹ï¼ˆå¤‰æ›´ãªã—ï¼‰
          const normalizedGazeY = (avgPupilY - 0.5) * 2;
          
          // ã‚¹ã‚±ãƒ¼ãƒ«ã—ã¦æœ€çµ‚çš„ãªå€¤ã«å¤‰æ›ï¼ˆ-50 to 50ã®ç¯„å›²ï¼‰
          this.gazeX = Math.max(-50, Math.min(50, normalizedGazeX * 50));
          this.gazeY = Math.max(-50, Math.min(50, normalizedGazeY * 50));
          
          // çœ¼çƒã®è©³ç´°ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ï¼ˆãƒ‡ãƒãƒƒã‚°ç”¨ï¼‰
          this.eyeballData = {
            left: leftEyeData,
            right: rightEyeData,
            avgPupilRatio: { x: avgPupilX, y: avgPupilY },
            rawGaze: { x: normalizedGazeX, y: normalizedGazeY }
          };
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: é¡”ã®å‘ããƒ™ãƒ¼ã‚¹ã®è¨ˆç®—
          this.calculateGazeFromFaceOrientation(landmarks);
        }
        
        // å‹•ããŒã‚ã£ãŸå ´åˆã¯è¨˜éŒ²
        if (Math.abs(this.gazeX) > this.scoreSettings.movementDetectionThreshold || 
            Math.abs(this.gazeY) > this.scoreSettings.movementDetectionThreshold) {
          this.lastMovementTime = Date.now();
        }
        
        // è¦–ç·šãƒ‡ãƒ¼ã‚¿ã®ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°å‡¦ç†
        this.applySmoothingToGaze();
        
        // çœ¼çƒå‹•ãã®å¤‰åŒ–é‡ã‚’è¨ˆç®—ï¼ˆã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®ãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼‰
        this.calculateGazeMovementDelta();
        
        // é¡”ã®å‘ãã‚’è¨ˆç®—
        this.calculateHeadPoseFromLandmarks(landmarks);
        
      } catch (error) {
        console.error('è¦–ç·šè¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
        // ã‚¨ãƒ©ãƒ¼æ™‚ã¯ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤
        this.gazeX = 0;
        this.gazeY = 0;
        // å¤‰åŒ–é‡ã‚‚ãƒªã‚»ãƒƒãƒˆ
        this.gazeVelocity = { x: 0, y: 0 };
        this.headPoseX = 0;
        this.headPoseY = 0;
        this.headPoseVelocity = { x: 0, y: 0 };
      }
    }
    
    getDetailedEyeData(landmarks, eye) {
      try {
        let eyeIndices, irisIndices;
        
        if (eye === 'left') {
          // å·¦ç›®ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ï¼ˆ468ç‚¹Face Meshã‚ˆã‚Šï¼‰
          eyeIndices = [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246];
          // å·¦ç›®ã®è™¹å½©å‘¨è¾ºã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯
          irisIndices = [468, 469, 470, 471, 472]; // MediaPipe iris landmarksã®ä¸€éƒ¨
        } else {
          // å³ç›®ã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯
          eyeIndices = [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398];
          // å³ç›®ã®è™¹å½©å‘¨è¾ºã®ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯
          irisIndices = [473, 474, 475, 476, 477]; // MediaPipe iris landmarksã®ä¸€éƒ¨
        }
        
        // ç›®ã®ãƒã‚¦ãƒ³ãƒ‡ã‚£ãƒ³ã‚°ãƒœãƒƒã‚¯ã‚¹ã‚’è¨ˆç®—
        const eyePoints = eyeIndices.map(i => landmarks[i]).filter(p => p);
        if (eyePoints.length === 0) {
          return { isValid: false };
        }
        
        const minX = Math.min(...eyePoints.map(p => p.x));
        const maxX = Math.max(...eyePoints.map(p => p.x));
        const minY = Math.min(...eyePoints.map(p => p.y));
        const maxY = Math.max(...eyePoints.map(p => p.y));
        
        const eyeWidth = maxX - minX;
        const eyeHeight = maxY - minY;
        const eyeCenter = { x: (minX + maxX) / 2, y: (minY + maxY) / 2 };
        
        // ç³å­”ä½ç½®ã®æ¨å®šï¼ˆè™¹å½©ä¸­å¿ƒã¾ãŸã¯ç›®ã®é‡å¿ƒï¼‰
        let pupilCenter;
        
        // è™¹å½©ãƒ©ãƒ³ãƒ‰ãƒãƒ¼ã‚¯ãŒåˆ©ç”¨å¯èƒ½ãªå ´åˆ
        const irisPoints = irisIndices.map(i => landmarks[i]).filter(p => p);
        if (irisPoints.length > 0) {
          // è™¹å½©ã®ä¸­å¿ƒã‚’è¨ˆç®—
          pupilCenter = {
            x: irisPoints.reduce((sum, p) => sum + p.x, 0) / irisPoints.length,
            y: irisPoints.reduce((sum, p) => sum + p.y, 0) / irisPoints.length
          };
        } else {
          // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: ç›®ã®å†…å´ã®ç‚¹ã‚’ä½¿ç”¨ã—ã¦ç³å­”ä½ç½®ã‚’æ¨å®š
          const innerCorner = eye === 'left' ? landmarks[133] : landmarks[362];
          const outerCorner = eye === 'left' ? landmarks[33] : landmarks[263];
          const upperLid = eye === 'left' ? landmarks[159] : landmarks[386];
          const lowerLid = eye === 'left' ? landmarks[145] : landmarks[374];
          
          if (innerCorner && outerCorner && upperLid && lowerLid) {
            // ç›®ã®é–‹é–‰åº¦ã‚’è¨ˆç®—
            const eyeOpenness = Math.abs(upperLid.y - lowerLid.y);
            const eyeWidth = Math.abs(outerCorner.x - innerCorner.x);
            const openRatio = eyeOpenness / (eyeWidth * 0.3); // æ­£å¸¸ãªé–‹çœ¼æ™‚ã®æ¯”ç‡
            
            // ç›®ãŒååˆ†é–‹ã„ã¦ã„ã‚‹å ´åˆã®ã¿ç³å­”ä½ç½®ã‚’æ¨å®š
            if (openRatio > 0.3) {
              // ã¾ã¶ãŸã®æ›²ç·šã‹ã‚‰ç³å­”ä½ç½®ã‚’æ¨å®š
              const lidCenterX = (innerCorner.x + outerCorner.x) / 2;
              const lidCenterY = (upperLid.y + lowerLid.y) / 2;
              
              // ç›®ã®å½¢çŠ¶ã«åŸºã¥ãå¾®èª¿æ•´
              // é€šå¸¸ã€ç³å­”ã¯ç›®ã®ä¸­å¤®ã‚ˆã‚Šã‚ãšã‹ã«å†…å´å¯„ã‚Šã«ã‚ã‚‹
              const adjustX = eye === 'left' ? 0.45 : 0.55; // å·¦ç›®ã¯å†…å´å¯„ã‚Šã€å³ç›®ã¯å¤–å´å¯„ã‚Š
              const adjustY = 0.4; // ç³å­”ã¯é€šå¸¸ä¸Šã¾ã¶ãŸå¯„ã‚Š
              
              pupilCenter = {
                x: innerCorner.x + (outerCorner.x - innerCorner.x) * adjustX,
                y: upperLid.y + (lowerLid.y - upperLid.y) * adjustY
              };
            } else {
              // ç›®ãŒé–‰ã˜ã¦ã„ã‚‹å ´åˆã¯ä¸­å¤®ã‚’ä½¿ç”¨
              pupilCenter = eyeCenter;
            }
          } else {
            pupilCenter = eyeCenter;
          }
        }
        
        // ç³å­”ã®ç›¸å¯¾ä½ç½®ã‚’è¨ˆç®—ï¼ˆ0-1ã®ç¯„å›²ï¼‰
        const pupilRatio = {
          x: eyeWidth > 0 ? (pupilCenter.x - minX) / eyeWidth : 0.5,
          y: eyeHeight > 0 ? (pupilCenter.y - minY) / eyeHeight : 0.5
        };
        
        // çµæœã‚’è¿”ã™
        return {
          isValid: true,
          eyeCenter,
          pupilCenter,
          pupilRatio,
          eyeBounds: { minX, maxX, minY, maxY, width: eyeWidth, height: eyeHeight },
          confidence: irisPoints.length > 0 ? 0.9 : 0.6 // è™¹å½©ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã¯é«˜ã„ä¿¡é ¼åº¦
        };
        
      } catch (error) {
        console.error(`${eye}ç›®ã®ãƒ‡ãƒ¼ã‚¿å–å¾—ã‚¨ãƒ©ãƒ¼:`, error);
        return { isValid: false };
      }
    }
    
    calculateGazeFromFaceOrientation(landmarks) {
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®é¡”ã®å‘ããƒ™ãƒ¼ã‚¹ã®è¨ˆç®—
      try {
        const leftEye = this.getEyeCenter(landmarks, [33, 7, 163, 144, 145, 153, 154, 155, 133, 173, 157, 158, 159, 160, 161, 246]);
        const rightEye = this.getEyeCenter(landmarks, [362, 382, 381, 380, 374, 373, 390, 249, 263, 466, 388, 387, 386, 385, 384, 398]);
        const faceCenter = landmarks[9];
        
        const eyeCenter = {
          x: (leftEye.x + rightEye.x) / 2,
          y: (leftEye.y + rightEye.y) / 2
        };
        
        const faceWidth = Math.abs(leftEye.x - rightEye.x);
        const faceHeight = Math.abs(landmarks[10].y - landmarks[152].y);
        
        // ã‚«ãƒ¡ãƒ©æ˜ åƒãŒå·¦å³åè»¢ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€Xåº§æ¨™ã‚‚åè»¢
        const normalizedGazeX = -((eyeCenter.x - faceCenter.x) / (faceWidth * 0.5));
        const normalizedGazeY = (eyeCenter.y - faceCenter.y) / (faceHeight * 0.5);
        
        this.gazeX = Math.max(-50, Math.min(50, normalizedGazeX * 50));
        this.gazeY = Math.max(-50, Math.min(50, normalizedGazeY * 50));
        
      } catch (error) {
        console.error('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯è¦–ç·šè¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
        this.gazeX = 0;
        this.gazeY = 0;
      }
    }
    
    getEyeCenter(landmarks, eyeIndices) {
      let sumX = 0, sumY = 0;
      for (const index of eyeIndices) {
        if (landmarks[index]) {
          sumX += landmarks[index].x;
          sumY += landmarks[index].y;
        }
      }
      return {
        x: sumX / eyeIndices.length,
        y: sumY / eyeIndices.length
      };
    }
    
    applySmoothingToGaze() {
      const currentTime = Date.now();
      
      // ç”Ÿã®è¦–ç·šãƒ‡ãƒ¼ã‚¿ã‚’å±¥æ­´ã«è¿½åŠ 
      this.gazeRawHistory.push({
        x: this.gazeX,
        y: this.gazeY,
        timestamp: currentTime
      });
      
      // å±¥æ­´ã®ã‚µã‚¤ã‚ºã‚’åˆ¶é™
      if (this.gazeRawHistory.length > this.smoothingWindowSize) {
        this.gazeRawHistory.shift();
      }
      
      // ãƒã‚¤ã‚ºé™¤å»: æ¥µç«¯ãªå€¤ã‚’æ¤œå‡ºã—ã¦é™¤å»
      const filteredHistory = this.removeNoiseFromGazeData();
      
      if (filteredHistory.length >= 3) {
        // ç§»å‹•å¹³å‡ã‚’è¨ˆç®—
        const smoothedX = filteredHistory.reduce((sum, data) => sum + data.x, 0) / filteredHistory.length;
        const smoothedY = filteredHistory.reduce((sum, data) => sum + data.y, 0) / filteredHistory.length;
        
        // é‡ã¿ä»˜ãå¹³å‡ï¼ˆæ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã«ã‚ˆã‚Šå¤§ããªé‡ã¿ã‚’ä»˜ã‘ã‚‹ï¼‰
        const weights = filteredHistory.map((_, index) => Math.pow(1.2, index)); // æ–°ã—ã„ãƒ‡ãƒ¼ã‚¿ã»ã©é‡ã„
        const totalWeight = weights.reduce((sum, weight) => sum + weight, 0);
        
        const weightedX = filteredHistory.reduce((sum, data, index) => sum + data.x * weights[index], 0) / totalWeight;
        const weightedY = filteredHistory.reduce((sum, data, index) => sum + data.y * weights[index], 0) / totalWeight;
        
        // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°çµæœã‚’ä¿å­˜
        this.gazeSmoothed.x = weightedX;
        this.gazeSmoothed.y = weightedY;
        
        // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°å¾Œã®ãƒ‡ãƒ¼ã‚¿ã§å…ƒã®å€¤ã‚’æ›´æ–°
        this.gazeX = weightedX;
        this.gazeY = weightedY;
        
        // æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã¨ã—ã¦è¨˜éŒ²
        this.lastValidGaze = { x: weightedX, y: weightedY, timestamp: currentTime };
      } else if (this.lastValidGaze.timestamp > 0 && (currentTime - this.lastValidGaze.timestamp) < 500) {
        // ãƒ‡ãƒ¼ã‚¿ãŒä¸è¶³ã—ã¦ã„ã‚‹å ´åˆã¯å‰å›ã®æœ‰åŠ¹ãªãƒ‡ãƒ¼ã‚¿ã‚’ä½¿ç”¨ï¼ˆ0.5ç§’ä»¥å†…ï¼‰
        this.gazeX = this.lastValidGaze.x;
        this.gazeY = this.lastValidGaze.y;
      }
    }
    
    calculateHeadPoseFromLandmarks(landmarks) {
      try {
        // é¡”ã®ä¸»è¦ãªç‰¹å¾´ç‚¹ã‚’ä½¿ç”¨ã—ã¦å‘ãã‚’è¨ˆç®—
        const noseTip = landmarks[1]; // é¼»å…ˆ
        const faceCenter = landmarks[9]; // é¡”ã®ä¸­å¿ƒ
        const leftEyeCorner = landmarks[33]; // å·¦ç›®å°»
        const rightEyeCorner = landmarks[263]; // å³ç›®å°»
        const chinCenter = landmarks[18]; // é¡ã®ä¸­å¿ƒ
        const foreheadCenter = landmarks[10]; // é¡ã®ä¸­å¿ƒ
        
        if (!noseTip || !faceCenter || !leftEyeCorner || !rightEyeCorner || !chinCenter || !foreheadCenter) {
          return;
        }
        
        // é¡”ã®åŸºæº–ã‚µã‚¤ã‚ºã‚’è¨ˆç®—
        const faceWidth = Math.abs(leftEyeCorner.x - rightEyeCorner.x);
        const faceHeight = Math.abs(foreheadCenter.y - chinCenter.y);
        
        // æ°´å¹³æ–¹å‘ã®å‘ãï¼ˆå·¦å³ã®å›è»¢ï¼‰
        // é¼»å…ˆã¨é¡”ã®ä¸­å¿ƒã®æ°´å¹³æ–¹å‘ã®ãšã‚Œã§åˆ¤å®š
        const horizontalOffset = (noseTip.x - faceCenter.x) / (faceWidth * 0.5);
        
        // å‚ç›´æ–¹å‘ã®å‘ãï¼ˆä¸Šä¸‹ã®å‚¾ãï¼‰
        // é¼»å…ˆã¨é¡”ã®ä¸­å¿ƒã®å‚ç›´æ–¹å‘ã®ãšã‚Œã§åˆ¤å®š
        const verticalOffset = (noseTip.y - faceCenter.y) / (faceHeight * 0.5);
        
        // ã‚«ãƒ¡ãƒ©æ˜ åƒãŒå·¦å³åè»¢ã•ã‚Œã¦ã„ã‚‹ãŸã‚ã€Xåº§æ¨™ã‚‚åè»¢
        this.headPoseX = Math.max(-50, Math.min(50, -horizontalOffset * 50));
        this.headPoseY = Math.max(-50, Math.min(50, verticalOffset * 50));
        
        // é¡”ã®å‘ãã®å¤‰åŒ–é‡ã‚’è¨ˆç®—
        this.calculateHeadPoseMovementDelta();
        
      } catch (error) {
        console.error('é¡”ã®å‘ãè¨ˆç®—ã‚¨ãƒ©ãƒ¼:', error);
        this.headPoseX = 0;
        this.headPoseY = 0;
      }
    }
    
    calculateHeadPoseMovementDelta() {
      const currentTime = Date.now();
      const currentHeadPose = { x: this.headPoseX, y: this.headPoseY };
      
      // å‰å›ã®è¨˜éŒ²ã‹ã‚‰ã®æ™‚é–“å·®ï¼ˆç§’ï¼‰
      const deltaTime = (currentTime - this.previousHeadPose.timestamp) / 1000;
      
      if (deltaTime > 0 && deltaTime < 1.0) { // 1ç§’ä»¥å†…ã®å¤‰åŒ–ã®ã¿æœ‰åŠ¹
        // é€Ÿåº¦è¨ˆç®—ï¼ˆè§’åº¦/ç§’ï¼‰
        let velocityX = (currentHeadPose.x - this.previousHeadPose.x) / deltaTime;
        let velocityY = (currentHeadPose.y - this.previousHeadPose.y) / deltaTime;
        
        // é€Ÿåº¦å€¤ã®ç•°å¸¸ãƒã‚§ãƒƒã‚¯ï¼ˆæ€¥æ¿€ãªå¤‰åŒ–ã‚’åˆ¶é™ï¼‰
        const maxVelocity = 100; // æœ€å¤§é€Ÿåº¦åˆ¶é™
        velocityX = Math.max(-maxVelocity, Math.min(maxVelocity, velocityX));
        velocityY = Math.max(-maxVelocity, Math.min(maxVelocity, velocityY));
        
        // é€Ÿåº¦ã«ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ã‚’é©ç”¨
        const velocitySmoothing = 0.4; // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ä¿‚æ•°
        this.headPoseVelocity.x = this.headPoseVelocity.x * (1 - velocitySmoothing) + velocityX * velocitySmoothing;
        this.headPoseVelocity.y = this.headPoseVelocity.y * (1 - velocitySmoothing) + velocityY * velocitySmoothing;
      } else {
        // æ™‚é–“å·®ãŒå¤§ãã„å ´åˆã¯é€Ÿåº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
        this.headPoseVelocity.x = 0;
        this.headPoseVelocity.y = 0;
      }
      
      // å‰å›ã®ä½ç½®ã‚’æ›´æ–°
      this.previousHeadPose = { 
        x: currentHeadPose.x, 
        y: currentHeadPose.y, 
        timestamp: currentTime 
      };
    }
    
    removeNoiseFromGazeData() {
      if (this.gazeRawHistory.length < 3) {
        return this.gazeRawHistory;
      }
      
      const filtered = [];
      
      for (let i = 0; i < this.gazeRawHistory.length; i++) {
        const current = this.gazeRawHistory[i];
        let isNoise = false;
        
        // å‰å¾Œã®ãƒ‡ãƒ¼ã‚¿ã¨æ¯”è¼ƒã—ã¦ãƒã‚¤ã‚ºã‚’æ¤œå‡º
        if (i > 0 && i < this.gazeRawHistory.length - 1) {
          const prev = this.gazeRawHistory[i - 1];
          const next = this.gazeRawHistory[i + 1];
          
          // å‰å¾Œã®ãƒ‡ãƒ¼ã‚¿ã¨ã®å·®ãŒé–¾å€¤ã‚’è¶…ãˆã‚‹å ´åˆã¯ãƒã‚¤ã‚ºã¨åˆ¤å®š
          const diffPrev = Math.sqrt(Math.pow(current.x - prev.x, 2) + Math.pow(current.y - prev.y, 2));
          const diffNext = Math.sqrt(Math.pow(current.x - next.x, 2) + Math.pow(current.y - next.y, 2));
          const diffPrevNext = Math.sqrt(Math.pow(prev.x - next.x, 2) + Math.pow(prev.y - next.y, 2));
          
          // ç¾åœ¨ã®å€¤ãŒå‰å¾Œã‹ã‚‰å¤§ããé›¢ã‚Œã¦ã„ã‚‹å ´åˆã¯ãƒã‚¤ã‚º
          if (diffPrev > this.noiseThreshold && diffNext > this.noiseThreshold && diffPrevNext < this.noiseThreshold) {
            isNoise = true;
          }
        }
        
        // æ¥µç«¯ã«å¤§ããªå€¤ã‚‚ãƒã‚¤ã‚ºã¨ã—ã¦é™¤å»
        if (Math.abs(current.x) > 100 || Math.abs(current.y) > 100) {
          isNoise = true;
        }
        
        if (!isNoise) {
          filtered.push(current);
        }
      }
      
      return filtered.length > 0 ? filtered : this.gazeRawHistory;
    }
    
    calculateGazeMovementDelta() {
      const currentTime = Date.now();
      const currentGaze = { x: this.gazeX, y: this.gazeY }; // ã™ã§ã«ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°æ¸ˆã¿
      
      // å‰å›ã®è¨˜éŒ²ã‹ã‚‰ã®æ™‚é–“å·®ï¼ˆç§’ï¼‰
      const deltaTime = (currentTime - this.previousGaze.timestamp) / 1000;
      
      if (deltaTime > 0 && deltaTime < 1.0) { // 1ç§’ä»¥å†…ã®å¤‰åŒ–ã®ã¿æœ‰åŠ¹
        // é€Ÿåº¦è¨ˆç®—ï¼ˆãƒ”ã‚¯ã‚»ãƒ«/ç§’ï¼‰
        let velocityX = (currentGaze.x - this.previousGaze.x) / deltaTime;
        let velocityY = (currentGaze.y - this.previousGaze.y) / deltaTime;
        
        // é€Ÿåº¦å€¤ã®ç•°å¸¸ãƒã‚§ãƒƒã‚¯ï¼ˆæ€¥æ¿€ãªå¤‰åŒ–ã‚’åˆ¶é™ï¼‰
        const maxVelocity = 200; // æœ€å¤§é€Ÿåº¦åˆ¶é™ï¼ˆãƒ”ã‚¯ã‚»ãƒ«/ç§’ï¼‰
        velocityX = Math.max(-maxVelocity, Math.min(maxVelocity, velocityX));
        velocityY = Math.max(-maxVelocity, Math.min(maxVelocity, velocityY));
        
        // é€Ÿåº¦ã«ã‚‚ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ã‚’é©ç”¨ï¼ˆå‰å›ã®é€Ÿåº¦ã¨ã®å¹³å‡ï¼‰
        const velocitySmoothing = 0.3; // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°ä¿‚æ•°
        this.gazeVelocity.x = this.gazeVelocity.x * (1 - velocitySmoothing) + velocityX * velocitySmoothing;
        this.gazeVelocity.y = this.gazeVelocity.y * (1 - velocitySmoothing) + velocityY * velocitySmoothing;
        
        // å‹•ãå±¥æ­´ã‚’æ›´æ–°ï¼ˆæœ€æ–°5ãƒ•ãƒ¬ãƒ¼ãƒ åˆ†ï¼‰
        this.eyeMovementHistory.push({
          position: { ...currentGaze },
          velocity: { x: velocityX, y: velocityY },
          timestamp: currentTime
        });
        
        // å±¥æ­´ã®é•·ã•ã‚’åˆ¶é™
        if (this.eyeMovementHistory.length > 5) {
          this.eyeMovementHistory.shift();
        }
      } else {
        // æ™‚é–“å·®ãŒå¤§ãã„å ´åˆã¯é€Ÿåº¦ã‚’ãƒªã‚»ãƒƒãƒˆ
        this.gazeVelocity.x = 0;
        this.gazeVelocity.y = 0;
      }
      
      // å‰å›ã®ä½ç½®ã‚’æ›´æ–°
      this.previousGaze = { 
        x: currentGaze.x, 
        y: currentGaze.y, 
        timestamp: currentTime 
      };
    }
    
    updateFrontFacingRatio() {
      // æ­£é¢å‘ãã‹ã©ã†ã‹ã®åˆ¤å®š
      const isFrontFacing = Math.abs(this.gazeX) < 20 && Math.abs(this.gazeY) < 20;
      this.frontFacingRatio = isFrontFacing ? 
        Math.min(100, this.frontFacingRatio + 2) : 
        Math.max(60, this.frontFacingRatio - 1);
    }
    
    startGazeOverlayUpdates() {
      // è¦–ç·šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®æ›´æ–°ã‚’é–‹å§‹ï¼ˆ30fpsï¼‰
      if (this.gazeOverlayInterval) {
        clearInterval(this.gazeOverlayInterval);
      }
      this.gazeOverlayInterval = setInterval(() => {
        this.updateGazeOverlay();
      }, 33); // ç´„30fps
    }
    
    stopGazeOverlayUpdates() {
      // è¦–ç·šã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ã®æ›´æ–°ã‚’åœæ­¢
      if (this.gazeOverlayInterval) {
        clearInterval(this.gazeOverlayInterval);
        this.gazeOverlayInterval = null;
      }
    }
    
    startTracking() {
      setInterval(() => {
        this.updateFaceTracking();
        this.calculateConcentration();
        this.updateGauge();
        this.updateDebugInfo();
      }, 1000); // 1ç§’ã”ã¨ã«æ›´æ–°
    }
    
    updateFaceTracking() {
      // MediaPipeãŒä½¿ç”¨å¯èƒ½ã§åˆæœŸåŒ–æ¸ˆã¿ã®å ´åˆã¯ã€MediaPipeã«å‡¦ç†ã‚’å§”ã­ã‚‹
      if (this.useMediaPipe && this.mediaPipeInitialized) {
        // MediaPipeã®onFaceMeshResultsãƒ¡ã‚½ãƒƒãƒ‰ã§å‡¦ç†ã•ã‚Œã‚‹ãŸã‚ã€ã“ã“ã§ã¯ä½•ã‚‚ã—ãªã„
        console.log('MediaPipeã§è¦–ç·šæ¤œå‡ºä¸­...');
        return;
      }
      
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯: å¾“æ¥ã®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ–¹å¼
      if (!this.cameraVideo || !this.canvas) return;
      
      try {
        console.log('ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰ã§è¦–ç·šæ¤œå‡ºä¸­...');
        
        // ã‚«ãƒ¡ãƒ©æ˜ åƒã‚’canvasã«æç”»
        this.ctx.drawImage(this.cameraVideo, 0, 0, 640, 480);
        const imageData = this.ctx.getImageData(0, 0, 640, 480);
        
        // ç°¡æ˜“çš„ãªé¡”æ¤œå‡ºï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼‰
        this.faceDetected = this.detectFace(imageData);
        
        if (this.faceDetected) {
          // ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³æ–¹å¼ã®ç›®ç·šæ–¹å‘è¨ˆç®—
          const time = Date.now() / 1000;
          this.gazeX = Math.sin(time * 0.5) * 30 + Math.random() * 10 - 5; // -35 to 35
          this.gazeY = Math.cos(time * 0.3) * 20 + Math.random() * 10 - 5; // -25 to 25
          
          // å‹•ããŒã‚ã£ãŸå ´åˆã¯è¨˜éŒ²
          if (Math.abs(this.gazeX) > 10 || Math.abs(this.gazeY) > 10) {
            this.lastMovementTime = Date.now();
          }
        }
        
        // æ­£é¢å‘ãå‰²åˆã®æ›´æ–°
        this.updateFrontFacingRatio();
        
        // ãƒ‡ãƒãƒƒã‚°Canvasã«æç”»
        this.updateGazeOverlay();

      } catch (error) {
        console.error('é¡”è¿½è·¡ã‚¨ãƒ©ãƒ¼:', error);
      }
    }
    
    updateGazeOverlay() {
      const overlayCanvas = document.getElementById('gaze-overlay-canvas');
      if (!overlayCanvas) return;
      
      const ctx = overlayCanvas.getContext('2d');
      ctx.clearRect(0, 0, 320, 240);
      
      // ã‚­ãƒ£ãƒ³ãƒã‚¹ã‚’å·¦å³åè»¢ï¼ˆãƒ“ãƒ‡ã‚ªã«åˆã‚ã›ã‚‹ï¼‰
      ctx.save();
      ctx.scale(-1, 1);
      ctx.translate(-320, 0);
      
      if (this.faceDetected) {
        // ã‚«ãƒ¡ãƒ©æ˜ åƒã®ä¸­å¿ƒã‚’åŸºæº–ç‚¹ã¨ã™ã‚‹
        const centerX = 160; // 320/2
        const centerY = 120; // 240/2
        
        // ç›®ç·šæ–¹å‘ã‚’æ­£è¦åŒ–ãƒ™ã‚¯ãƒˆãƒ«ã¨ã—ã¦è¨ˆç®—
        // gazeX, gazeYã®ç¯„å›²ã¯-50ã€œ50ãªã®ã§ã€ã“ã‚Œã‚’æ­£è¦åŒ–
        const magnitude = Math.sqrt(this.gazeX * this.gazeX + this.gazeY * this.gazeY);
        
        if (magnitude > 0) {
          // æ­£è¦åŒ–ãƒ™ã‚¯ãƒˆãƒ«
          const normalizedX = this.gazeX / magnitude;
          const normalizedY = this.gazeY / magnitude;
          
          // çŸ¢å°ã®é•·ã•ï¼ˆç”»é¢ã‚µã‚¤ã‚ºã«æ¯”ä¾‹ï¼‰
          const arrowLength = Math.min(magnitude * 2, 80); // æœ€å¤§80ãƒ”ã‚¯ã‚»ãƒ«
          
          // çŸ¢å°ã®çµ‚ç‚¹
          const endX = centerX + normalizedX * arrowLength;
          const endY = centerY + normalizedY * arrowLength;
          
          // çŸ¢å°æœ¬ä½“ã‚’æç”»
          ctx.strokeStyle = '#00ff00'; // æ˜ã‚‹ã„ç·‘
          ctx.lineWidth = 4;
          ctx.beginPath();
          ctx.moveTo(centerX, centerY);
          ctx.lineTo(endX, endY);
          ctx.stroke();
          
          // çŸ¢å°ã®å…ˆç«¯ã‚’æç”»
          if (arrowLength > 10) {
            const arrowHeadLength = 15;
            const arrowHeadAngle = Math.PI / 6; // 30åº¦
            
            // çŸ¢å°ã®è§’åº¦
            const angle = Math.atan2(normalizedY, normalizedX);
            
            // çŸ¢å°ã®å…ˆç«¯ã®2ã¤ã®ç·š
            ctx.beginPath();
            ctx.moveTo(endX, endY);
            ctx.lineTo(
              endX - arrowHeadLength * Math.cos(angle - arrowHeadAngle),
              endY - arrowHeadLength * Math.sin(angle - arrowHeadAngle)
            );
            ctx.moveTo(endX, endY);
            ctx.lineTo(
              endX - arrowHeadLength * Math.cos(angle + arrowHeadAngle),
              endY - arrowHeadLength * Math.sin(angle + arrowHeadAngle)
            );
            ctx.stroke();
          }
          
          // ä¸­å¿ƒç‚¹ã‚’è¡¨ç¤º
          ctx.fillStyle = '#ff0000'; // èµ¤ã„ä¸­å¿ƒç‚¹
          ctx.beginPath();
          ctx.arc(centerX, centerY, 4, 0, 2 * Math.PI);
          ctx.fill();
          
          // ãƒ™ã‚¯ãƒˆãƒ«æƒ…å ±ã‚’ãƒ†ã‚­ã‚¹ãƒˆã§è¡¨ç¤ºï¼ˆãƒ†ã‚­ã‚¹ãƒˆã¯åè»¢ã•ã›ãªã„ï¼‰
          ctx.save();
          ctx.scale(-1, 1);
          ctx.translate(-320, 0);
          
          ctx.fillStyle = '#ffffff';
          ctx.font = '12px Arial';
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 2;
          
          const vectorText = `è¦–ç·šV(${normalizedX.toFixed(2)}, ${normalizedY.toFixed(2)})`;
          const magnitudeText = `|V|=${magnitude.toFixed(1)}`;
          
          // ãƒ†ã‚­ã‚¹ãƒˆã«ç¸å–ã‚Šã‚’ä»˜ã‘ã¦è¦‹ã‚„ã™ãã™ã‚‹
          ctx.strokeText(vectorText, 10, 20);
          ctx.fillText(vectorText, 10, 20);
          ctx.strokeText(magnitudeText, 10, 40);
          ctx.fillText(magnitudeText, 10, 40);
          
          ctx.restore();
        } else {
          // ä¸­å¿ƒç‚¹ã®ã¿è¡¨ç¤ºï¼ˆè¦–ç·šãŒæ­£é¢ã®å ´åˆï¼‰
          ctx.fillStyle = '#00ff00';
          ctx.beginPath();
          ctx.arc(centerX, centerY, 6, 0, 2 * Math.PI);
          ctx.fill();
          
          // æ­£é¢è¦–ç·šã®ãƒ†ã‚­ã‚¹ãƒˆï¼ˆãƒ†ã‚­ã‚¹ãƒˆã¯åè»¢ã•ã›ãªã„ï¼‰
          ctx.save();
          ctx.scale(-1, 1);
          ctx.translate(-320, 0);
          
          ctx.fillStyle = '#ffffff';
          ctx.font = '12px Arial';
          ctx.strokeStyle = '#000000';
          ctx.lineWidth = 2;
          ctx.strokeText('æ­£é¢è¦–ç·š', 10, 20);
          ctx.fillText('æ­£é¢è¦–ç·š', 10, 20);
          
          ctx.restore();
        }
        
        // çœ¼çƒå‹•ãã®å¤‰åŒ–é‡ãƒ™ã‚¯ãƒˆãƒ«ã‚’æç”»
        this.drawMovementVectors(ctx, centerX, centerY);
        
      } else {
        // é¡”æœªæ¤œå‡ºæ™‚ã®è¡¨ç¤º
        ctx.strokeStyle = '#ff0000';
        ctx.lineWidth = 3;
        ctx.font = '16px Arial';
        ctx.fillStyle = '#ffffff';
        
        // Xå°ã‚’æç”»
        ctx.beginPath();
        ctx.moveTo(140, 100);
        ctx.lineTo(180, 140);
        ctx.moveTo(180, 100);
        ctx.lineTo(140, 140);
        ctx.stroke();
        
        // ãƒ†ã‚­ã‚¹ãƒˆè¡¨ç¤ºï¼ˆãƒ†ã‚­ã‚¹ãƒˆã¯åè»¢ã•ã›ãªã„ï¼‰
        ctx.save();
        ctx.scale(-1, 1);
        ctx.translate(-320, 0);
        
        ctx.strokeText('é¡”æœªæ¤œå‡º', 130, 160);
        ctx.fillText('é¡”æœªæ¤œå‡º', 130, 160);
        
        ctx.restore();
      }
      
      // ã‚­ãƒ£ãƒ³ãƒã‚¹å¤‰æ›ã‚’å¾©å…ƒ
      ctx.restore();
    }
    
    drawMovementVectors(ctx, centerX, centerY) {
      // è¦–ç·šé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã®æç”»ï¼ˆé’è‰²ï¼‰
      const velocityMagnitude = Math.sqrt(this.gazeVelocity.x * this.gazeVelocity.x + this.gazeVelocity.y * this.gazeVelocity.y);
      
      if (velocityMagnitude > 1) { // é–¾å€¤ä»¥ä¸Šã®é€Ÿåº¦ã®ã¿è¡¨ç¤º
        const velocityScale = 2; // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã®è¡¨ç¤ºã‚¹ã‚±ãƒ¼ãƒ«
        const velocityLength = Math.min(velocityMagnitude * velocityScale, 60);
        
        // æ­£è¦åŒ–ã•ã‚ŒãŸé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
        const normalizedVelX = this.gazeVelocity.x / velocityMagnitude;
        const normalizedVelY = this.gazeVelocity.y / velocityMagnitude;
        
        // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã®çµ‚ç‚¹
        const velEndX = centerX + normalizedVelX * velocityLength;
        const velEndY = centerY + normalizedVelY * velocityLength;
        
        // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’æç”»ï¼ˆé’è‰²ï¼‰
        ctx.strokeStyle = '#0099ff';
        ctx.lineWidth = 3;
        ctx.setLineDash([5, 3]); // ç ´ç·šã§è¡¨ç¤º
        ctx.beginPath();
        ctx.moveTo(centerX, centerY);
        ctx.lineTo(velEndX, velEndY);
        ctx.stroke();
        
        // é€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã®çŸ¢å°
        if (velocityLength > 15) {
          const arrowHeadLength = 10;
          const arrowHeadAngle = Math.PI / 5;
          const velAngle = Math.atan2(normalizedVelY, normalizedVelX);
          
          ctx.beginPath();
          ctx.moveTo(velEndX, velEndY);
          ctx.lineTo(
            velEndX - arrowHeadLength * Math.cos(velAngle - arrowHeadAngle),
            velEndY - arrowHeadLength * Math.sin(velAngle - arrowHeadAngle)
          );
          ctx.moveTo(velEndX, velEndY);
          ctx.lineTo(
            velEndX - arrowHeadLength * Math.cos(velAngle + arrowHeadAngle),
            velEndY - arrowHeadLength * Math.sin(velAngle + arrowHeadAngle)
          );
          ctx.stroke();
        }
        
        ctx.setLineDash([]); // ç ´ç·šã‚’è§£é™¤
      }
      
      // é¡”ã®å‘ããƒ™ã‚¯ãƒˆãƒ«ã®æç”»ï¼ˆã‚ªãƒ¬ãƒ³ã‚¸è‰²ï¼‰
      const headPoseMagnitude = Math.sqrt(this.headPoseX * this.headPoseX + this.headPoseY * this.headPoseY);
      
      if (headPoseMagnitude > 2) { // é–¾å€¤ä»¥ä¸Šã®é¡”ã®å‘ãã®ã¿è¡¨ç¤º
        const headPoseScale = 1.5; // é¡”ã®å‘ããƒ™ã‚¯ãƒˆãƒ«ã®è¡¨ç¤ºã‚¹ã‚±ãƒ¼ãƒ«
        const headPoseLength = Math.min(headPoseMagnitude * headPoseScale, 50);
        
        // æ­£è¦åŒ–ã•ã‚ŒãŸé¡”ã®å‘ããƒ™ã‚¯ãƒˆãƒ«
        const normalizedHeadPoseX = this.headPoseX / headPoseMagnitude;
        const normalizedHeadPoseY = this.headPoseY / headPoseMagnitude;
        
        // é¡”ã®å‘ããƒ™ã‚¯ãƒˆãƒ«ã®çµ‚ç‚¹ï¼ˆå°‘ã—ã‚ªãƒ•ã‚»ãƒƒãƒˆã—ã¦è¡¨ç¤ºï¼‰
        const offsetX = 25;
        const offsetY = 25;
        const headPoseStartX = centerX + offsetX;
        const headPoseStartY = centerY + offsetY;
        const headPoseEndX = headPoseStartX + normalizedHeadPoseX * headPoseLength;
        const headPoseEndY = headPoseStartY + normalizedHeadPoseY * headPoseLength;
        
        // é¡”ã®å‘ããƒ™ã‚¯ãƒˆãƒ«ã‚’æç”»ï¼ˆã‚ªãƒ¬ãƒ³ã‚¸è‰²ï¼‰
        ctx.strokeStyle = '#ff6600';
        ctx.lineWidth = 2;
        ctx.setLineDash([4, 3]); // ç‚¹ç·š
        ctx.beginPath();
        ctx.moveTo(headPoseStartX, headPoseStartY);
        ctx.lineTo(headPoseEndX, headPoseEndY);
        ctx.stroke();
        
        // é¡”ã®å‘ããƒ™ã‚¯ãƒˆãƒ«ã®çŸ¢å°
        if (headPoseLength > 10) {
          const arrowHeadLength = 8;
          const arrowHeadAngle = Math.PI / 4;
          const headPoseAngle = Math.atan2(normalizedHeadPoseY, normalizedHeadPoseX);
          
          ctx.beginPath();
          ctx.moveTo(headPoseEndX, headPoseEndY);
          ctx.lineTo(
            headPoseEndX - arrowHeadLength * Math.cos(headPoseAngle - arrowHeadAngle),
            headPoseEndY - arrowHeadLength * Math.sin(headPoseAngle - arrowHeadAngle)
          );
          ctx.moveTo(headPoseEndX, headPoseEndY);
          ctx.lineTo(
            headPoseEndX - arrowHeadLength * Math.cos(headPoseAngle + arrowHeadAngle),
            headPoseEndY - arrowHeadLength * Math.sin(headPoseAngle + arrowHeadAngle)
          );
          ctx.stroke();
        }
        
        ctx.setLineDash([]); // ç ´ç·šã‚’è§£é™¤
      }
      
      // é¡”ã®å‘ãé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã®æç”»ï¼ˆç´«è‰²ï¼‰
      const headPoseVelocityMagnitude = Math.sqrt(this.headPoseVelocity.x * this.headPoseVelocity.x + this.headPoseVelocity.y * this.headPoseVelocity.y);
      
      if (headPoseVelocityMagnitude > 1) { // é–¾å€¤ä»¥ä¸Šã®é¡”ã®å‘ãé€Ÿåº¦ã®ã¿è¡¨ç¤º
        const headPoseVelScale = 3; // é¡”ã®å‘ãé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã®è¡¨ç¤ºã‚¹ã‚±ãƒ¼ãƒ«
        const headPoseVelLength = Math.min(headPoseVelocityMagnitude * headPoseVelScale, 45);
        
        // æ­£è¦åŒ–ã•ã‚ŒãŸé¡”ã®å‘ãé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«
        const normalizedHeadPoseVelX = this.headPoseVelocity.x / headPoseVelocityMagnitude;
        const normalizedHeadPoseVelY = this.headPoseVelocity.y / headPoseVelocityMagnitude;
        
        // é¡”ã®å‘ãé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã®çµ‚ç‚¹ï¼ˆã•ã‚‰ã«ã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰
        const velOffsetX = -25;
        const velOffsetY = 25;
        const headPoseVelStartX = centerX + velOffsetX;
        const headPoseVelStartY = centerY + velOffsetY;
        const headPoseVelEndX = headPoseVelStartX + normalizedHeadPoseVelX * headPoseVelLength;
        const headPoseVelEndY = headPoseVelStartY + normalizedHeadPoseVelY * headPoseVelLength;
        
        // é¡”ã®å‘ãé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã‚’æç”»ï¼ˆç´«è‰²ï¼‰
        ctx.strokeStyle = '#9966ff';
        ctx.lineWidth = 2;
        ctx.setLineDash([2, 4]); // çŸ­ã„ç ´ç·š
        ctx.beginPath();
        ctx.moveTo(headPoseVelStartX, headPoseVelStartY);
        ctx.lineTo(headPoseVelEndX, headPoseVelEndY);
        ctx.stroke();
        
        // é¡”ã®å‘ãé€Ÿåº¦ãƒ™ã‚¯ãƒˆãƒ«ã®çŸ¢å°
        if (headPoseVelLength > 10) {
          const arrowHeadLength = 7;
          const arrowHeadAngle = Math.PI / 5;
          const headPoseVelAngle = Math.atan2(normalizedHeadPoseVelY, normalizedHeadPoseVelX);
          
          ctx.beginPath();
          ctx.moveTo(headPoseVelEndX, headPoseVelEndY);
          ctx.lineTo(
            headPoseVelEndX - arrowHeadLength * Math.cos(headPoseVelAngle - arrowHeadAngle),
            headPoseVelEndY - arrowHeadLength * Math.sin(headPoseVelAngle - arrowHeadAngle)
          );
          ctx.moveTo(headPoseVelEndX, headPoseVelEndY);
          ctx.lineTo(
            headPoseVelEndX - arrowHeadLength * Math.cos(headPoseVelAngle + arrowHeadAngle),
            headPoseVelEndY - arrowHeadLength * Math.sin(headPoseVelAngle + arrowHeadAngle)
          );
          ctx.stroke();
        }
        
        ctx.setLineDash([]); // ç ´ç·šã‚’è§£é™¤
      }
      
      // å¤‰åŒ–é‡ã®æ•°å€¤æƒ…å ±ã‚’è¡¨ç¤ºï¼ˆãƒ†ã‚­ã‚¹ãƒˆã¯åè»¢ã•ã›ãªã„ï¼‰
      ctx.save();
      ctx.scale(-1, 1);
      ctx.translate(-320, 0);
      
      ctx.fillStyle = '#ffffff';
      ctx.font = '10px Arial';
      ctx.strokeStyle = '#000000';
      ctx.lineWidth = 1;
      
      const gazeVelocityText = `è¦–ç·šé€Ÿåº¦: (${this.gazeVelocity.x.toFixed(1)}, ${this.gazeVelocity.y.toFixed(1)}) px/s`;
      const gazeVelocityMagText = `|è¦–ç·šé€Ÿåº¦|=${velocityMagnitude.toFixed(1)}`;
      const headPoseText = `é¡”å‘ã: (${this.headPoseX.toFixed(1)}, ${this.headPoseY.toFixed(1)})`;
      const headPoseVelocityText = `é¡”å‘ãé€Ÿåº¦: (${this.headPoseVelocity.x.toFixed(1)}, ${this.headPoseVelocity.y.toFixed(1)}) deg/s`;
      
      // å³å´ã«æƒ…å ±ã‚’è¡¨ç¤º
      ctx.strokeText(gazeVelocityText, 10, 60);
      ctx.fillText(gazeVelocityText, 10, 60);
      ctx.strokeText(gazeVelocityMagText, 10, 75);
      ctx.fillText(gazeVelocityMagText, 10, 75);
      ctx.strokeText(headPoseText, 10, 90);
      ctx.fillText(headPoseText, 10, 90);
      ctx.strokeText(headPoseVelocityText, 10, 105);
      ctx.fillText(headPoseVelocityText, 10, 105);
      
      // å‡¡ä¾‹ã‚’è¡¨ç¤º
      ctx.font = '8px Arial';
      ctx.strokeText('â” è¦–ç·šæ–¹å‘(ç·‘) â”… è¦–ç·šé€Ÿåº¦(é’) â”„ é¡”å‘ã(æ©™) â”ˆ é¡”å‘ãé€Ÿåº¦(ç´«)', 10, 220);
      ctx.fillText('â” è¦–ç·šæ–¹å‘(ç·‘) â”… è¦–ç·šé€Ÿåº¦(é’) â”„ é¡”å‘ã(æ©™) â”ˆ é¡”å‘ãé€Ÿåº¦(ç´«)', 10, 220);
      
      ctx.restore();
    }
    
    detectFace(imageData) {
      // ç°¡æ˜“çš„ãªé¡”æ¤œå‡ºï¼ˆæ˜åº¦ãƒ™ãƒ¼ã‚¹ï¼‰
      // å®Ÿéš›ã®å®Ÿè£…ã§ã¯é¡”æ¤œå‡ºãƒ©ã‚¤ãƒ–ãƒ©ãƒªã‚’ä½¿ç”¨
      const data = imageData.data;
      let brightness = 0;
      for (let i = 0; i < data.length; i += 4) {
        brightness += (data[i] + data[i + 1] + data[i + 2]) / 3;
      }
      const avgBrightness = brightness / (data.length / 4);
      return avgBrightness > 50; // æ˜åº¦ãŒ50ä»¥ä¸Šãªã‚‰é¡”ãŒã‚ã‚‹ã¨åˆ¤å®š
    }
    
    calculateConcentration() {
      const oldScore = this.score;
      let newScore = this.score; // ç¾åœ¨ã®ã‚¹ã‚³ã‚¢ã‹ã‚‰é–‹å§‹
      const reasons = [];
      
      // é¡”ãŒæ¤œå‡ºã•ã‚Œãªã„å ´åˆã¯æ¸›ç‚¹
      if (!this.faceDetected) {
        const penalty = this.scoreSettings.faceNotDetectedPenalty;
        newScore -= penalty;
        reasons.push({ 
          text: 'é¡”æœªæ¤œå‡º', 
          change: -penalty, 
          type: 'negative',
          category: 'ã‚«ãƒ¡ãƒ©',
          detail: 'ã‚«ãƒ¡ãƒ©ã«é¡”ãŒæ˜ ã£ã¦ã„ã¾ã›ã‚“'
        });
      } else {
        // æ­£é¢å‘ãã®è©•ä¾¡ï¼ˆé–“éš”åˆ¶å¾¡ä»˜ãåŠ ç‚¹ï¼‰
        const currentTime = Date.now();
        if (this.frontFacingRatio > 80 && 
            (currentTime - this.lastFrontFacingBonus) >= this.scoreSettings.frontFacingInterval) {
          const bonus = this.scoreSettings.frontFacingBonus;
          newScore += bonus;
          this.lastFrontFacingBonus = currentTime;
          reasons.push({ 
            text: 'æ­£é¢æ³¨è¦–', 
            change: bonus, 
            type: 'positive',
            category: 'å§¿å‹¢',
            detail: `æ­£é¢ã‚’å‘ã„ã¦ã„ã¾ã™ (æ­£é¢ç‡:${this.frontFacingRatio.toFixed(1)}%)`
          });
        }
        
        // ç›®ç·šæ–¹å‘ã«ã‚ˆã‚‹è©•ä¾¡ï¼ˆé–“éš”åˆ¶å¾¡ä»˜ãåŠ ç‚¹ï¼‰
        if (Math.abs(this.gazeX) < this.scoreSettings.centerGazeThreshold && 
            Math.abs(this.gazeY) < this.scoreSettings.centerGazeThreshold &&
            (currentTime - this.lastCenterGazeBonus) >= this.scoreSettings.centerGazeInterval) {
          const bonus = this.scoreSettings.centerGazeBonus;
          newScore += bonus;
          this.lastCenterGazeBonus = currentTime;
          reasons.push({ 
            text: 'é›†ä¸­æ³¨è¦–', 
            change: bonus, 
            type: 'positive',
            category: 'ç›®ç·š',
            detail: 'ç”»é¢ä¸­å¤®ã‚’æ³¨è¦–ã—ã¦ã„ã¾ã™'
          });
        }
        // ç›®ç·šã‚’ãã‚‰ã™ã“ã¨è‡ªä½“ã¯æ¸›ç‚¹å¯¾è±¡ã‹ã‚‰é™¤å¤–
        
        // å•é¡Œè¡¨ç¤ºå¾Œã®ç›®ç·šã®å‹•ãï¼ˆå³å‘ãã®è¦–ç·šé€Ÿåº¦ã‚’è©•ä¾¡ï¼‰
        if (this.questionDisplayTime && !this.responseStartTime && !this.questionConfirmed) {
          const timeFromQuestion = (Date.now() - this.questionDisplayTime) / 1000;
          if (timeFromQuestion < this.scoreSettings.questionConfirmWindow) {
            // å³å‘ãã®è¦–ç·šé€Ÿåº¦ã‚’ãƒã‚§ãƒƒã‚¯
            if (this.gazeVelocity.x > this.scoreSettings.gazeVelocityThreshold) {
              const gazeBonus = this.scoreSettings.questionConfirmBonus;
              newScore += gazeBonus;
              this.questionConfirmed = true; // ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã¦ä¸€åº¦ã ã‘å®Ÿè¡Œ
              reasons.push({ 
                text: 'å•é¡Œç¢ºèª', 
                change: gazeBonus, 
                type: 'positive',
                category: 'ç›®ç·š',
                detail: `å•é¡Œè¡¨ç¤ºå¾Œ${timeFromQuestion.toFixed(1)}ç§’ã§å³å‘ãé€Ÿåº¦${this.gazeVelocity.x.toFixed(1)}px/sã‚’æ¤œå‡ºã—ã¾ã—ãŸ`
              });
            }
          }
        }
        
        // ä¸€å®šæ™‚é–“å‹•ããŒãªã„å ´åˆã¯æ¸›ç‚¹
        const timeSinceMovement = (Date.now() - this.lastMovementTime) / 1000;
        if (timeSinceMovement > this.scoreSettings.movementStopThreshold) {
          const penalty = Math.min(20, (timeSinceMovement - this.scoreSettings.movementStopThreshold) * this.scoreSettings.movementStopPenalty);
          newScore -= penalty;
          reasons.push({ 
            text: `ç›®ç·šåœæ­¢`, 
            change: -penalty, 
            type: 'negative',
            category: 'ç›®ç·š',
            detail: `${timeSinceMovement.toFixed(1)}ç§’é–“ç›®ç·šã®å‹•ããŒã‚ã‚Šã¾ã›ã‚“`
          });
        }
        
        // å‡ºé¡Œã‹ã‚‰å›ç­”ã¾ã§ã®æ™‚é–“ãŒé•·ã„å ´åˆã¯æ¸›ç‚¹
        if (this.questionDisplayTime && this.responseStartTime && !this.responseProcessed) {
          const responseTime = (this.responseStartTime - this.questionDisplayTime) / 1000;
          if (responseTime > this.scoreSettings.responseDelayThreshold) {
            const penalty = Math.min(15, (responseTime - this.scoreSettings.responseDelayThreshold) * this.scoreSettings.responseDelayPenalty);
            newScore -= penalty;
            reasons.push({ 
              text: `å›ç­”é…å»¶`, 
              change: -penalty, 
              type: 'negative',
              category: 'åå¿œ',
              detail: `å•é¡Œè¡¨ç¤ºã‹ã‚‰å›ç­”ã¾ã§${responseTime.toFixed(1)}ç§’ã‹ã‹ã‚Šã¾ã—ãŸ`
            });
          } else if (responseTime < this.scoreSettings.quickResponseThreshold) {
            const bonus = this.scoreSettings.quickResponseBonus;
            newScore += bonus;
            reasons.push({ 
              text: `ç´ æ—©ã„å›ç­”`, 
              change: bonus, 
              type: 'positive',
              category: 'åå¿œ',
              detail: `å•é¡Œè¡¨ç¤ºã‹ã‚‰${responseTime.toFixed(1)}ç§’ã§å›ç­”ã—ã¾ã—ãŸ`
            });
          }
          // ä¸€åº¦å‡¦ç†ã—ãŸã‚‰ãƒ•ãƒ©ã‚°ã‚’ç«‹ã¦ã‚‹
          this.responseProcessed = true;
        }
        
      }
      
      // ãƒ¡ãƒ¢å…¥åŠ›ãŒã‚ã£ãŸå ´åˆã¯åŠ ç‚¹ï¼ˆå‰å›ãƒã‚§ãƒƒã‚¯æ™‚ã‹ã‚‰ã®å¢—åˆ†ã®ã¿ï¼‰
      if (this.noteInputs > this.lastNoteCount) {
        const newNotes = this.noteInputs - this.lastNoteCount;
        const noteBonus = newNotes * this.scoreSettings.noteInputBonus;
        newScore += noteBonus;
        reasons.push({ 
          text: `ãƒ¡ãƒ¢å…¥åŠ›`, 
          change: noteBonus, 
          type: 'positive',
          category: 'ãƒ¡ãƒ¢',
          detail: `${newNotes}å›ã®ãƒ¡ãƒ¢å…¥åŠ›ãŒã‚ã‚Šã¾ã—ãŸ`
        });
        this.lastNoteCount = this.noteInputs;
      }
      
      // ã‚¹ã‚³ã‚¢ã‚’0-100ã®ç¯„å›²ã«åˆ¶é™
      this.score = Math.max(0, Math.min(100, newScore));
      
      // ãƒ­ã‚°ã«è¨˜éŒ²ï¼ˆã‚¹ã‚³ã‚¢ãŒå¤‰åŒ–ã—ãŸå ´åˆã€ã¾ãŸã¯ç†ç”±ãŒã‚ã‚‹å ´åˆï¼‰
      if (Math.abs(this.score - oldScore) > 0.1 || reasons.length > 0) {
        this.addLog(reasons, oldScore, this.score);
        
        // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨˜éŒ²ï¼ˆã‚¹ã‚³ã‚¢ãŒå¤‰åŒ–ã—ãŸå ´åˆã®ã¿ï¼‰
        if (Math.abs(this.score - oldScore) > 0.1) {
          const change = this.score - oldScore;
          const changeStr = change > 0 ? `+${change.toFixed(1)}` : change.toFixed(1);
          const reasonTexts = reasons.map(r => r.text).join(', ');
          
          this.addTimestamp('score_change', `é›†ä¸­åº¦å¤‰åŒ–: ${changeStr}ç‚¹ (${reasonTexts})`, {
            scoreChange: change,
            previousScore: oldScore,
            newScore: this.score,
            reasons: reasons
          });
        }
      }
    }
    
    addLog(reasons, oldScore, newScore) {
      const timestamp = new Date().toLocaleTimeString();
      const change = newScore - oldScore;
      
      // ãƒ¡ã‚¤ãƒ³ã®ãƒ­ã‚°ãƒ†ã‚­ã‚¹ãƒˆ
      let logText = `[${timestamp}] ${oldScore.toFixed(0)} â†’ ${newScore.toFixed(0)} (${change > 0 ? '+' : ''}${change.toFixed(0)})`;
      
      // è©³ç´°ãªåŸå› æƒ…å ±
      let detailText = '';
      if (reasons.length > 0) {
        const categoryGroups = {};
        reasons.forEach(r => {
          if (!categoryGroups[r.category]) {
            categoryGroups[r.category] = [];
          }
          categoryGroups[r.category].push(r);
        });
        
        const categoryTexts = Object.keys(categoryGroups).map(category => {
          const items = categoryGroups[category];
          const categoryChange = items.reduce((sum, item) => sum + item.change, 0);
          const itemTexts = items.map(item => 
            `${item.text}(${item.change > 0 ? '+' : ''}${item.change.toFixed(0)})`
          ).join(', ');
          
          return `ã€${category}ã€‘${itemTexts}`;
        });
        
        logText += ': ' + categoryTexts.join(' | ');
        
        // è©³ç´°æƒ…å ±ã‚’åˆ¥é€”ä½œæˆ
        detailText = reasons.map(r => `â€¢ ${r.detail}`).join('\n');
      }
      
      this.logs.unshift({
        text: logText,
        detail: detailText,
        reasons: reasons,
        type: this.determineLogType(change, reasons),
        timestamp: Date.now(),
        change: change
      });
      
      // ãƒ­ã‚°ã¯æœ€æ–°20ä»¶ã¾ã§ä¿æŒ
      if (this.logs.length > 20) {
        this.logs = this.logs.slice(0, 20);
      }
      
      this.updateLogDisplay();
    }
    
    determineLogType(change, reasons) {
      // ã‚¹ã‚³ã‚¢å¤‰åŒ–é‡ã§åŸºæœ¬çš„ãªåˆ¤å®š
      if (change > 0) {
        return 'positive';
      } else if (change < 0) {
        return 'negative';
      } else {
        // å¤‰åŒ–é‡ãŒ0ã®å ´åˆã€ç†ç”±ã®å†…å®¹ã§åˆ¤å®š
        if (reasons.length > 0) {
          const positiveReasons = reasons.filter(r => r.type === 'positive');
          const negativeReasons = reasons.filter(r => r.type === 'negative');
          
          if (positiveReasons.length > 0 && negativeReasons.length === 0) {
            return 'positive'; // ãƒ—ãƒ©ã‚¹è¦å› ã®ã¿ï¼ˆã‚¹ã‚³ã‚¢ä¸Šé™ã«ã‚ˆã‚‹åˆ¶é™ï¼‰
          } else if (negativeReasons.length > 0 && positiveReasons.length === 0) {
            return 'negative'; // ãƒã‚¤ãƒŠã‚¹è¦å› ã®ã¿
          }
        }
        return 'neutral';
      }
    }
    
    updateLogDisplay() {
      if (!this.logElement) return;
      
      this.logElement.innerHTML = this.logs.map((log, index) => {
        const expandId = `log-expand-${index}`;
        return `
          <div class="log-entry ${log.type}" onclick="this.querySelector('.log-detail').style.display = this.querySelector('.log-detail').style.display === 'none' ? 'block' : 'none';">
            <div class="log-main">${log.text}</div>
            ${log.detail ? `<div class="log-detail" style="display: none;">${log.detail}</div>` : ''}
          </div>
        `;
      }).join('');
    }
    
    showDebugTab(tabName) {
      console.log('showDebugTab called with:', tabName);
      
      // ã™ã¹ã¦ã®ã‚¿ãƒ–ã‚’éè¡¨ç¤º
      document.querySelectorAll('.debug-tab-content').forEach(tab => {
        tab.style.display = 'none';
      });
      
      // ã™ã¹ã¦ã®ã‚¿ãƒ–ãƒœã‚¿ãƒ³ã‚’inactiveã«
      document.querySelectorAll('.debug-tab-btn').forEach(btn => {
        btn.classList.remove('active');
      });
      
      // é¸æŠã•ã‚ŒãŸã‚¿ãƒ–ã‚’è¡¨ç¤º
      const targetTab = document.getElementById(`debug-tab-${tabName}`);
      if (targetTab) {
        targetTab.style.display = 'block';
        console.log(`Showing tab: debug-tab-${tabName}`);
      } else {
        console.log(`Tab not found: debug-tab-${tabName}`);
      }
      
      // å¯¾å¿œã™ã‚‹ãƒœã‚¿ãƒ³ã‚’activeã«
      if (event && event.target) {
        event.target.classList.add('active');
      }
      
      // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ã‚¿ãƒ–ãŒé¸æŠã•ã‚ŒãŸå ´åˆã¯å¼·åˆ¶çš„ã«æ›´æ–°
      if (tabName === 'timestamp') {
        console.log('Timestamp tab selected, forcing update');
        this.updateTimestampDisplay();
      }
    }
    
    updateGauge() {
      // ã™ã¹ã¦ã®ãƒ¬ãƒ™ãƒ«ã‚’ãƒªã‚»ãƒƒãƒˆ
      Object.values(this.gaugeElements).forEach(element => {
        if (element && element.classList) {
          element.classList.remove('active');
        }
      });
      
      // ã‚¹ã‚³ã‚¢ã«å¿œã˜ã¦ã‚²ãƒ¼ã‚¸ã‚’æ›´æ–°
      if (this.score >= 75) {
        this.gaugeElements.green?.classList.add('active');
      } else if (this.score >= 50) {
        this.gaugeElements.yellow?.classList.add('active');
      } else if (this.score >= 25) {
        this.gaugeElements.orange?.classList.add('active');
      } else {
        this.gaugeElements.red?.classList.add('active');
      }
      
      if (this.gaugeElements.score) {
        this.gaugeElements.score.textContent = Math.round(this.score) + '%';
      }
    }
    
    updateDebugInfo() {
      // æ¤œå‡ºæ–¹å¼ã®è¡¨ç¤º
      if (this.debugElements.detectionMethod) {
        const method = this.useMediaPipe && this.mediaPipeInitialized ? 'MediaPipe (å®Ÿéš›ã®çœ¼çƒè¿½è·¡)' : 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ (é¡”ã®å‘ã)';
        this.debugElements.detectionMethod.textContent = method;
      }
      
      if (this.debugElements.faceDetected) {
        const detectionMethod = this.useMediaPipe && this.mediaPipeInitialized ? 'MediaPipe' : 'ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯';
        this.debugElements.faceDetected.textContent = this.faceDetected ? `æ¤œå‡º (${detectionMethod})` : `æœªæ¤œå‡º (${detectionMethod})`;
      }
      
      // ç›®ç·šæ–¹å‘ã‚’åˆ†ã‹ã‚Šã‚„ã™ãè¡¨ç¤º
      if (this.debugElements.gazeX) {
        const horizontalDirection = this.gazeX > 15 ? 'å³' : 
                                   this.gazeX < -15 ? 'å·¦' : 'ä¸­å¤®';
        this.debugElements.gazeX.textContent = `${this.gazeX.toFixed(1)} (${horizontalDirection})`;
      }
      if (this.debugElements.gazeY) {
        const verticalDirection = this.gazeY > 15 ? 'ä¸‹' : 
                                 this.gazeY < -15 ? 'ä¸Š' : 'ä¸­å¤®';
        this.debugElements.gazeY.textContent = `${this.gazeY.toFixed(1)} (${verticalDirection})`;
      }
      
      // ç·åˆçš„ãªç›®ç·šæ–¹å‘ã‚’è¡¨ç¤º
      if (this.debugElements.gazeDirection) {
        let direction = '';
        
        // å‚ç›´æ–¹å‘ã‚’å…ˆã«åˆ¤å®š
        if (this.gazeY < -15) direction += 'ä¸Š';
        else if (this.gazeY > 15) direction += 'ä¸‹';
        
        // æ°´å¹³æ–¹å‘ã‚’å¾Œã«åˆ¤å®š
        if (this.gazeX < -15) direction += 'å·¦';
        else if (this.gazeX > 15) direction += 'å³';
        
        // æ­£é¢ã®å ´åˆ
        if (!direction) direction = 'æ­£é¢';
        
        this.debugElements.gazeDirection.textContent = direction;
      }
      
      // çœ¼çƒãƒ‡ãƒ¼ã‚¿ã®è©³ç´°è¡¨ç¤ºï¼ˆMediaPipeä½¿ç”¨æ™‚ã®ã¿ï¼‰
      if (this.eyeballData && this.debugElements.eyeballDetails) {
        const data = this.eyeballData;
        let details = '';
        
        if (data.left.isValid && data.right.isValid) {
          details += `å·¦ç›®ç³å­”: (${(data.left.pupilRatio.x * 100).toFixed(1)}%, ${(data.left.pupilRatio.y * 100).toFixed(1)}%)\n`;
          details += `å³ç›®ç³å­”: (${(data.right.pupilRatio.x * 100).toFixed(1)}%, ${(data.right.pupilRatio.y * 100).toFixed(1)}%)\n`;
          details += `å¹³å‡ç³å­”: (${(data.avgPupilRatio.x * 100).toFixed(1)}%, ${(data.avgPupilRatio.y * 100).toFixed(1)}%)\n`;
          details += `ç”Ÿè¦–ç·šå€¤: (${data.rawGaze.x.toFixed(3)}, ${data.rawGaze.y.toFixed(3)})\n`;
          details += `ä¿¡é ¼åº¦: L=${(data.left.confidence * 100).toFixed(0)}% R=${(data.right.confidence * 100).toFixed(0)}%\n\n`;
          
          // ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°æƒ…å ±ã‚’è¿½åŠ 
          details += `ã€ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°å‡¦ç†ã€‘\n`;
          details += `ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°å¾Œ: (${this.gazeSmoothed.x.toFixed(1)}, ${this.gazeSmoothed.y.toFixed(1)})\n`;
          details += `ç”Ÿãƒ‡ãƒ¼ã‚¿å±¥æ­´: ${this.gazeRawHistory.length}/${this.smoothingWindowSize}ãƒ•ãƒ¬ãƒ¼ãƒ \n`;
          const filteredCount = this.removeNoiseFromGazeData().length;
          details += `ãƒã‚¤ã‚ºé™¤å»å¾Œ: ${filteredCount}ãƒ•ãƒ¬ãƒ¼ãƒ \n`;
          details += `ãƒã‚¤ã‚ºé™¤å»ç‡: ${this.gazeRawHistory.length > 0 ? ((this.gazeRawHistory.length - filteredCount) / this.gazeRawHistory.length * 100).toFixed(1) : 0}%\n\n`;
          
          // å¤‰åŒ–é‡æƒ…å ±ã‚’è¿½åŠ 
          details += `ã€è¦–ç·šã®å‹•ãã€‘\n`;
          details += `è¦–ç·šé€Ÿåº¦: (${this.gazeVelocity.x.toFixed(1)}, ${this.gazeVelocity.y.toFixed(1)}) px/s\n`;
          details += `è¦–ç·šé€Ÿåº¦å¤§ãã•: ${Math.sqrt(this.gazeVelocity.x * this.gazeVelocity.x + this.gazeVelocity.y * this.gazeVelocity.y).toFixed(1)} px/s\n`;
          details += `å‹•ãå±¥æ­´: ${this.eyeMovementHistory.length}/5ãƒ•ãƒ¬ãƒ¼ãƒ \n\n`;
          
          // é¡”ã®å‘ãæƒ…å ±ã‚’è¿½åŠ 
          details += `ã€é¡”ã®å‘ãã€‘\n`;
          details += `é¡”å‘ã: (${this.headPoseX.toFixed(1)}, ${this.headPoseY.toFixed(1)})\n`;
          details += `é¡”å‘ãé€Ÿåº¦: (${this.headPoseVelocity.x.toFixed(1)}, ${this.headPoseVelocity.y.toFixed(1)}) deg/s\n`;
          details += `é¡”å‘ãå¤§ãã•: ${Math.sqrt(this.headPoseX * this.headPoseX + this.headPoseY * this.headPoseY).toFixed(1)}`;
        } else {
          details = 'çœ¼çƒãƒ‡ãƒ¼ã‚¿å–å¾—å¤±æ•— - ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ãƒ¢ãƒ¼ãƒ‰\n';
          details += `ã‚¹ãƒ ãƒ¼ã‚¸ãƒ³ã‚°å¾Œ: (${this.gazeSmoothed.x.toFixed(1)}, ${this.gazeSmoothed.y.toFixed(1)})\n`;
          details += `è¦–ç·šé€Ÿåº¦: (${this.gazeVelocity.x.toFixed(1)}, ${this.gazeVelocity.y.toFixed(1)}) px/s\n`;
          details += `é¡”å‘ã: (${this.headPoseX.toFixed(1)}, ${this.headPoseY.toFixed(1)})`;
        }
        
        this.debugElements.eyeballDetails.textContent = details;
      }
      
      if (this.debugElements.frontFacing) {
        this.debugElements.frontFacing.textContent = this.frontFacingRatio.toFixed(1);
      }
      if (this.debugElements.lastMovement) {
        const timeSince = (Date.now() - this.lastMovementTime) / 1000;
        this.debugElements.lastMovement.textContent = timeSince.toFixed(1);
      }
      if (this.debugElements.noteInputs) {
        this.debugElements.noteInputs.textContent = this.noteInputs;
      }
    }
    
    onQuestionDisplayed() {
      this.questionDisplayTime = Date.now();
      this.responseStartTime = null;
      this.responseProcessed = false; // æ–°ã—ã„å•é¡Œã§ãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
      this.questionConfirmed = false; // å•é¡Œç¢ºèªãƒ•ãƒ©ã‚°ã‚‚ãƒªã‚»ãƒƒãƒˆ
      
      // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨˜éŒ²
      this.addTimestamp('question_display', 'å•é¡Œè¡¨ç¤º', {
        questionDisplayed: true
      });
      
      // å•é¡Œè¡¨ç¤ºã‚’ãƒ­ã‚°ã«è¨˜éŒ²
      const timestamp = new Date().toLocaleTimeString();
      this.logs.unshift({
        text: `[${timestamp}] å•é¡Œè¡¨ç¤º`,
        detail: 'æ–°ã—ã„å•é¡ŒãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸã€‚ç›®ç·šã®å‹•ãã¨åå¿œæ™‚é–“ã®è¨ˆæ¸¬ã‚’é–‹å§‹ã—ã¾ã™ã€‚',
        reasons: [{
          text: 'å•é¡Œè¡¨ç¤º',
          change: 0,
          type: 'neutral',
          category: 'ã‚¤ãƒ™ãƒ³ãƒˆ',
          detail: 'æ–°ã—ã„å•é¡ŒãŒè¡¨ç¤ºã•ã‚Œã¾ã—ãŸã€‚ç›®ç·šã®å‹•ãã¨åå¿œæ™‚é–“ã®è¨ˆæ¸¬ã‚’é–‹å§‹ã—ã¾ã™ã€‚'
        }],
        type: 'neutral',
        timestamp: Date.now(),
        change: 0
      });
      
      // ãƒ­ã‚°ã¯æœ€æ–°20ä»¶ã¾ã§ä¿æŒ
      if (this.logs.length > 20) {
        this.logs = this.logs.slice(0, 20);
      }
      
      this.updateLogDisplay();
    }
    
    onResponseStarted() {
      this.responseStartTime = Date.now();
      
      // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨˜éŒ²
      const responseTime = this.questionDisplayTime ? 
        (this.responseStartTime - this.questionDisplayTime) / 1000 : 0;
      this.addTimestamp('answer_start', 'å›ç­”é–‹å§‹', {
        responseTime: responseTime
      });
      
      // å›ç­”é–‹å§‹ã‚’ãƒ­ã‚°ã«è¨˜éŒ²
      const timestamp = new Date().toLocaleTimeString();
      const responseTimeStr = this.questionDisplayTime ? 
        ((Date.now() - this.questionDisplayTime) / 1000).toFixed(1) : 'ä¸æ˜';
      
      this.logs.unshift({
        text: `[${timestamp}] å›ç­”é–‹å§‹ (${responseTimeStr}så¾Œ)`,
        detail: `å•é¡Œè¡¨ç¤ºã‹ã‚‰${responseTimeStr}ç§’å¾Œã«å›ç­”ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚`,
        reasons: [{
          text: 'å›ç­”é–‹å§‹',
          change: 0,
          type: 'neutral',
          category: 'ã‚¤ãƒ™ãƒ³ãƒˆ',
          detail: `å•é¡Œè¡¨ç¤ºã‹ã‚‰${responseTimeStr}ç§’å¾Œã«å›ç­”ã‚’é–‹å§‹ã—ã¾ã—ãŸã€‚`
        }],
        type: 'neutral',
        timestamp: Date.now(),
        change: 0
      });
      
      // ãƒ­ã‚°ã¯æœ€æ–°20ä»¶ã¾ã§ä¿æŒ
      if (this.logs.length > 20) {
        this.logs = this.logs.slice(0, 20);
      }
      
      this.updateLogDisplay();
    }
    
    onNoteInput() {
      this.noteInputs++;
      
      // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨˜éŒ²
      this.addTimestamp('interaction_note', `ãƒ¡ãƒ¢å…¥åŠ›ï¼ˆ${this.noteInputs}å›ç›®ï¼‰`, {
        noteCount: this.noteInputs
      });
      
      // ãƒ¡ãƒ¢å…¥åŠ›ã‚’å³åº§ã«ãƒ­ã‚°ã«è¨˜éŒ²
      const timestamp = new Date().toLocaleTimeString();
      const bonus = 2; // ãƒ¡ãƒ¢1å›ã«ã¤ã2ç‚¹
      
      this.logs.unshift({
        text: `[${timestamp}] ãƒ¡ãƒ¢å…¥åŠ› (+${bonus})`,
        detail: `ãƒ¡ãƒ¢ã‚¨ãƒªã‚¢ã«å…¥åŠ›ãŒã‚ã‚Šã€å­¦ç¿’æ„æ¬²ãŒè©•ä¾¡ã•ã‚Œã¾ã—ãŸï¼ˆç´¯è¨ˆ: ${this.noteInputs}å›ï¼‰`,
        reasons: [{
          text: 'ãƒ¡ãƒ¢å…¥åŠ›',
          change: bonus,
          type: 'positive',
          category: 'ãƒ¡ãƒ¢',
          detail: `ãƒ¡ãƒ¢ã‚¨ãƒªã‚¢ã«å…¥åŠ›ãŒã‚ã‚Šã€å­¦ç¿’æ„æ¬²ãŒè©•ä¾¡ã•ã‚Œã¾ã—ãŸï¼ˆç´¯è¨ˆ: ${this.noteInputs}å›ï¼‰`
        }],
        type: 'positive',
        timestamp: Date.now(),
        change: bonus
      });
      
      // ãƒ­ã‚°ã¯æœ€æ–°20ä»¶ã¾ã§ä¿æŒ
      if (this.logs.length > 20) {
        this.logs = this.logs.slice(0, 20);
      }
      
      this.updateLogDisplay();
    }
    
    // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨˜éŒ²ã‚·ã‚¹ãƒ†ãƒ 
    addTimestamp(eventType, description, additionalData = {}) {
      const currentTime = Date.now();
      const sessionElapsed = (currentTime - this.sessionStartTime) / 1000; // ç§’
      const videoTime = this.videoElement ? this.videoElement.currentTime : 0;
      
      const timestampEntry = {
        id: this.timestampLog.length + 1,
        timestamp: currentTime,
        sessionElapsed: sessionElapsed,
        videoTime: videoTime,
        eventType: eventType,
        description: description,
        concentrationScore: this.score,
        videoState: this.videoState,
        playbackRate: this.videoElement ? this.videoElement.playbackRate : 1.0,
        ...additionalData
      };
      
      this.timestampLog.push(timestampEntry);
      
      // ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã‚’è¿½åŠ 
      console.log(`[ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¿½åŠ ] ${eventType}: ${description}`, {
        totalEvents: this.timestampLog.length,
        sessionElapsed: sessionElapsed.toFixed(1) + 's',
        entry: timestampEntry
      });
      
      // ãƒ­ã‚°ã‚’æœ€æ–°1000ä»¶ã¾ã§ä¿æŒ
      if (this.timestampLog.length > 1000) {
        this.timestampLog = this.timestampLog.slice(-1000);
      }
      
      // ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ è¡¨ç¤ºã‚’æ›´æ–°
      this.updateTimestampDisplay();
      
      console.log(`[ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—] ${eventType}: ${description}`, timestampEntry);
    }
    
    formatTime(seconds) {
      const minutes = Math.floor(seconds / 60);
      const secs = Math.floor(seconds % 60);
      return `${minutes}:${secs.toString().padStart(2, '0')}`;
    }
    
    updateTimestampDisplay() {
      const timestampElement = document.getElementById('timestamp-log');
      
      // ãƒ‡ãƒãƒƒã‚°æƒ…å ±ã‚’è¿½åŠ 
      console.log('updateTimestampDisplay called:', {
        timestampElement: !!timestampElement,
        timestampLogLength: this.timestampLog.length,
        recentEvents: this.timestampLog.slice(-3)
      });
      
      if (!timestampElement) {
        console.warn('timestamp-log element not found');
        return;
      }
      
      if (this.timestampLog.length === 0) {
        timestampElement.innerHTML = `
          <div class="timestamp-entry">
            <div class="timestamp-header">
              <span class="timestamp-time">ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãƒ‡ãƒ¼ã‚¿ãªã—</span>
            </div>
            <div class="timestamp-body">
              <div class="timestamp-description">ã¾ã ã‚¤ãƒ™ãƒ³ãƒˆãŒè¨˜éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚å‹•ç”»ã‚’æ“ä½œã™ã‚‹ã¨ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãŒè¨˜éŒ²ã•ã‚Œã¾ã™ã€‚</div>
            </div>
          </div>
        `;
        return;
      }
      
      // æœ€æ–°10ä»¶ã‚’è¡¨ç¤º
      const recentLogs = this.timestampLog.slice(-10).reverse();
      
      timestampElement.innerHTML = recentLogs.map(entry => {
        const timeStr = new Date(entry.timestamp).toLocaleTimeString();
        const sessionStr = this.formatTime(entry.sessionElapsed);
        const videoStr = this.formatTime(entry.videoTime);
        
        let className = 'timestamp-entry';
        if (entry.eventType.includes('score')) className += ' score-event';
        else if (entry.eventType.includes('video')) className += ' video-event';
        else if (entry.eventType.includes('interaction')) className += ' interaction-event';
        
        return `
          <div class="${className}">
            <div class="timestamp-header">
              <span class="timestamp-time">${timeStr}</span>
              <span class="timestamp-type">${entry.eventType}</span>
              <span class="concentration-score">ã‚¹ã‚³ã‚¢: ${entry.concentrationScore.toFixed(0)}</span>
            </div>
            <div class="timestamp-body">
              <div class="timestamp-description">${entry.description}</div>
              <div class="timestamp-times">
                <span>çµŒé: ${sessionStr}</span>
                <span>å‹•ç”»: ${videoStr}</span>
                ${entry.playbackRate !== 1.0 ? `<span>é€Ÿåº¦: ${entry.playbackRate}x</span>` : ''}
              </div>
            </div>
          </div>
        `;
      }).join('');
    }
    
    exportTimestampLog() {
      const data = this.prepareSessionData();
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `learning-session-${new Date().toISOString().slice(0, 19).replace(/:/g, '-')}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }
    
    prepareSessionData() {
      // æ­£ã—ã„å‹•ç”»IDã®å–å¾—
      const pathParts = window.location.pathname.split('/');
      const videoId = pathParts[pathParts.length - 2]; // '/videos/{id}/player' ã‹ã‚‰ {id} ã‚’å–å¾—
      
      return {
        sessionInfo: {
          startTime: this.sessionStartTime,
          endTime: Date.now(),
          totalDuration: (Date.now() - this.sessionStartTime) / 1000,
          videoId: videoId
        },
        timestampLog: this.timestampLog,
        finalScore: this.score
      };
    }
    
    saveSessionToServer(useBeacon = false) {
      if (this.saveInProgress) {
        console.log('ä¿å­˜å‡¦ç†ãŒæ—¢ã«å®Ÿè¡Œä¸­ã®ãŸã‚ã‚¹ã‚­ãƒƒãƒ—');
        return;
      }
      
      console.log('=== ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¿å­˜é–‹å§‹ ===');
      console.log('useBeacon:', useBeacon);
      console.log('timestampLog length:', this.timestampLog.length);
      
      this.saveInProgress = true;
      const data = this.prepareSessionData();
      console.log('æº–å‚™ã•ã‚ŒãŸã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿:', data);
      
      // æ­£ã—ã„å‹•ç”»IDã®å–å¾—ï¼ˆURLãƒ‘ã‚¹ã‹ã‚‰ï¼‰
      const pathParts = window.location.pathname.split('/');
      const videoId = pathParts[pathParts.length - 2]; // '/videos/{id}/player' ã‹ã‚‰ {id} ã‚’å–å¾—
      console.log('URL pathname:', window.location.pathname);
      console.log('pathParts:', pathParts);
      console.log('videoId:', videoId);
      
      const payload = JSON.stringify({ session_data: JSON.stringify(data) });
      console.log('é€ä¿¡ãƒšã‚¤ãƒ­ãƒ¼ãƒ‰é•·:', payload.length);
      
      if (useBeacon && navigator.sendBeacon) {
        // sendBeaconã‚’ä½¿ç”¨ï¼ˆãƒšãƒ¼ã‚¸é›¢è„±æ™‚ã«ã‚ˆã‚Šç¢ºå®Ÿï¼‰
        const formData = new FormData();
        formData.append('session_data', JSON.stringify(data));
        
        // CSRF token ã®è¿½åŠ 
        const csrfToken = document.querySelector('meta[name="csrf-token"]').content;
        formData.append('authenticity_token', csrfToken);
        
        const beaconUrl = `/videos/${videoId}/management/save_session`;
        console.log('sendBeacon URL:', beaconUrl);
        const success = navigator.sendBeacon(beaconUrl, formData);
        if (success) {
          console.log('sendBeaconã§ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’é€ä¿¡ã—ã¾ã—ãŸ');
        } else {
          console.warn('sendBeaconã§ã®é€ä¿¡ã«å¤±æ•—ã€fetchã‚’è©¦è¡Œ');
          this.saveSessionToServer(false); // fallback
        }
        return;
      }
      
      // é€šå¸¸ã®fetchä½¿ç”¨
      console.log(`é€ä¿¡å…ˆURL: /videos/${videoId}/management/save_session`);
      console.log('é€ä¿¡ã™ã‚‹ãƒ‡ãƒ¼ã‚¿:', data);
      
      fetch(`/videos/${videoId}/management/save_session`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
        },
        body: payload
      })
      .then(response => response.json())
      .then(result => {
        if (result.success) {
          console.log(`ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ä¿å­˜ã—ã¾ã—ãŸ (${this.timestampLog.length - this.lastSaveEventCount}ä»¶):`, result.session_id);
          // ä¿å­˜æˆåŠŸæ™‚ã®ç®¡ç†å¤‰æ•°æ›´æ–°
          this.lastSaveTime = Date.now();
          this.lastSaveEventCount = this.timestampLog.length;
          localStorage.removeItem('pendingSessionData');
        } else {
          console.error('ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ä¿å­˜ã‚¨ãƒ©ãƒ¼:', result.error);
        }
      })
      .catch(error => {
        console.error('ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿é€ä¿¡ã‚¨ãƒ©ãƒ¼:', error);
        this.saveToLocalStorageBackup(data);
      })
      .finally(() => {
        this.saveInProgress = false;
      });
    }
    
    saveToLocalStorageBackup(data) {
      try {
        // æ­£ã—ã„å‹•ç”»IDã®å–å¾—
        const pathParts = window.location.pathname.split('/');
        const videoId = pathParts[pathParts.length - 2];
        
        const backupData = {
          ...data,
          videoId: videoId,
          saved: false,
          backupTime: Date.now()
        };
        localStorage.setItem('pendingSessionData', JSON.stringify(backupData));
        console.log('ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’localStorageã«ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ã—ã¾ã—ãŸ');
      } catch (e) {
        console.error('localStorageãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¤±æ•—:', e);
      }
    }
    
    initializeVideoTracking() {
      this.videoElement = document.getElementById('video-player');
      if (!this.videoElement) return;
      
      // å‹•ç”»ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
      this.videoElement.addEventListener('play', () => {
        this.videoState = 'playing';
        this.addTimestamp('video_play', 'å‹•ç”»å†ç”Ÿé–‹å§‹', {
          previousState: 'paused'
        });
      });
      
      this.videoElement.addEventListener('pause', () => {
        this.videoState = 'paused';
        this.addTimestamp('video_pause', 'å‹•ç”»ä¸€æ™‚åœæ­¢', {
          previousState: 'playing'
        });
      });
      
      this.videoElement.addEventListener('seeked', () => {
        const currentTime = this.videoElement.currentTime;
        const timeDiff = Math.abs(currentTime - this.lastVideoTime);
        
        if (timeDiff > 2) { // 2ç§’ä»¥ä¸Šã®ã‚¹ã‚­ãƒƒãƒ—
          const direction = currentTime > this.lastVideoTime ? 'å‰é€²' : 'å¾Œé€€';
          this.addTimestamp('video_skip', `å‹•ç”»ã‚¹ã‚­ãƒƒãƒ—ï¼ˆ${direction}ï¼‰`, {
            from: this.lastVideoTime,
            to: currentTime,
            skipAmount: timeDiff,
            direction: direction
          });
        }
        
        this.lastVideoTime = currentTime;
      });
      
      this.videoElement.addEventListener('ratechange', () => {
        const newRate = this.videoElement.playbackRate;
        this.addTimestamp('video_speed_change', `å†ç”Ÿé€Ÿåº¦å¤‰æ›´`, {
          from: this.lastPlaybackRate,
          to: newRate,
          speedChange: newRate / this.lastPlaybackRate
        });
        this.lastPlaybackRate = newRate;
      });
      
      this.videoElement.addEventListener('ended', () => {
        this.videoState = 'stopped';
        this.addTimestamp('video_end', 'å‹•ç”»è¦–è´å®Œäº†', {
          totalWatchTime: this.videoElement.duration,
          completionRate: 1.0
        });
      });
      
      // å®šæœŸçš„ãªå‹•ç”»æ™‚åˆ»æ›´æ–°
      setInterval(() => {
        if (this.videoElement && this.videoState === 'playing') {
          this.lastVideoTime = this.videoElement.currentTime;
        }
      }, 1000);
      
      // ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹ã‚’è¨˜éŒ²
      this.addTimestamp('session_start', 'å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³é–‹å§‹');
    }
    
    initializeTimestampPanel() {
      // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³
      const exportBtn = document.getElementById('export-timestamp');
      if (exportBtn) {
        exportBtn.addEventListener('click', () => {
          this.exportTimestampLog();
        });
      }
      
      // ã‚µãƒ¼ãƒãƒ¼ä¿å­˜ãƒœã‚¿ãƒ³
      const saveBtn = document.getElementById('save-to-server');
      if (saveBtn) {
        saveBtn.addEventListener('click', () => {
          this.saveSessionToServer();
          alert('ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ã‚µãƒ¼ãƒãƒ¼ã«ä¿å­˜ã—ã¾ã—ãŸ');
        });
      }
      
      // ã‚¯ãƒªã‚¢ãƒœã‚¿ãƒ³
      const clearBtn = document.getElementById('clear-timestamp');
      if (clearBtn) {
        clearBtn.addEventListener('click', () => {
          if (confirm('ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—ãƒ­ã‚°ã‚’ã‚¯ãƒªã‚¢ã—ã¾ã™ã‹ï¼Ÿ')) {
            this.timestampLog = [];
            this.updateTimestampDisplay();
            this.updateTimestampStats();
          }
        });
      }
      
      // çµ±è¨ˆã®å®šæœŸæ›´æ–°
      setInterval(() => {
        this.updateTimestampStats();
      }, 1000);
    }
    
    updateTimestampStats() {
      const sessionDurationEl = document.getElementById('session-duration');
      const videoTimeEl = document.getElementById('current-video-time');
      const eventCountEl = document.getElementById('event-count');
      
      if (sessionDurationEl) {
        const sessionElapsed = (Date.now() - this.sessionStartTime) / 1000;
        sessionDurationEl.textContent = this.formatTime(sessionElapsed);
      }
      
      if (videoTimeEl && this.videoElement) {
        videoTimeEl.textContent = this.formatTime(this.videoElement.currentTime || 0);
      }
      
      if (eventCountEl) {
        eventCountEl.textContent = this.timestampLog.length;
      }
    }
    
    setupBatchSaving() {
      // æ¡ä»¶ãƒ™ãƒ¼ã‚¹ã®è³¢ã„ä¿å­˜ã‚·ã‚¹ãƒ†ãƒ 
      setInterval(() => {
        this.checkAndSave();
      }, 15000); // 15ç§’é–“éš”ã§ãƒã‚§ãƒƒã‚¯
      
      // é‡è¦ã‚¤ãƒ™ãƒ³ãƒˆæ™‚ã®å³åº§ä¿å­˜
      this.setupCriticalEventSaving();
    }
    
    checkAndSave() {
      if (this.saveInProgress) return;
      
      const currentTime = Date.now();
      const timeSinceLastSave = (currentTime - this.lastSaveTime) / 1000;
      const newEvents = this.timestampLog.length - this.lastSaveEventCount;
      
      console.log(`=== ä¿å­˜æ¡ä»¶ãƒã‚§ãƒƒã‚¯ ===`);
      console.log(`æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆæ•°: ${newEvents}`);
      console.log(`æœ€å¾Œã®ä¿å­˜ã‹ã‚‰ã®çµŒéæ™‚é–“: ${timeSinceLastSave}ç§’`);
      console.log(`ç·ã‚¤ãƒ™ãƒ³ãƒˆæ•°: ${this.timestampLog.length}`);
      
      // ä¿å­˜æ¡ä»¶ï¼ˆã„ãšã‚Œã‹ã‚’æº€ãŸã™ï¼‰- ãƒ‡ãƒãƒƒã‚°ç”¨ã«æ¡ä»¶ã‚’ç·©å’Œ
      const shouldSave = 
        newEvents >= 3 ||                     // æ–°ã—ã„ã‚¤ãƒ™ãƒ³ãƒˆãŒ3å€‹ä»¥ä¸Šï¼ˆç·©å’Œï¼‰
        timeSinceLastSave >= 60 ||            // 1åˆ†çµŒéï¼ˆç·©å’Œï¼‰
        (newEvents >= 1 && timeSinceLastSave >= 30) ||  // 30ç§’çµŒé + 1ã‚¤ãƒ™ãƒ³ãƒˆä»¥ä¸Šï¼ˆç·©å’Œï¼‰
        this.hasHighPriorityEvents();         // é‡è¦ã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚‹
      
      console.log(`ä¿å­˜ã™ã¹ãã‹: ${shouldSave}`);
      
      if (shouldSave && newEvents > 0) {
        console.log('æ¡ä»¶ã‚’æº€ãŸã—ãŸãŸã‚ä¿å­˜ã‚’å®Ÿè¡Œã—ã¾ã™');
        this.saveSessionToServer();
      } else {
        console.log('ä¿å­˜æ¡ä»¶ã‚’æº€ãŸã—ã¦ã„ã¾ã›ã‚“');
      }
    }
    
    hasHighPriorityEvents() {
      // æœ€å¾Œã®ä¿å­˜ä»¥é™ã«é‡è¦ãªã‚¤ãƒ™ãƒ³ãƒˆãŒã‚ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      const recentEvents = this.timestampLog.slice(this.lastSaveEventCount);
      return recentEvents.some(event => 
        event.eventType.includes('question') ||
        event.eventType.includes('answer') ||
        event.eventType.includes('video_end') ||
        (event.eventType.includes('score_change') && Math.abs(event.additionalData?.scoreChange || 0) >= 5)
      );
    }
    
    setupCriticalEventSaving() {
      // é‡è¦ã‚¤ãƒ™ãƒ³ãƒˆæ™‚ã¯å³åº§ã«ä¿å­˜ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
      const originalAddTimestamp = this.addTimestamp.bind(this);
      this.addTimestamp = (eventType, description, additionalData = {}) => {
        // å…ƒã®å‡¦ç†ã‚’å®Ÿè¡Œ
        originalAddTimestamp(eventType, description, additionalData);
        
        // é‡è¦ã‚¤ãƒ™ãƒ³ãƒˆã®å ´åˆã¯å„ªå…ˆä¿å­˜ã‚’ã‚¹ã‚±ã‚¸ãƒ¥ãƒ¼ãƒ«
        if (this.isCriticalEvent(eventType, additionalData)) {
          clearTimeout(this.criticalSaveTimeout);
          this.criticalSaveTimeout = setTimeout(() => {
            if (!this.saveInProgress) {
              this.saveSessionToServer();
            }
          }, 2000); // 2ç§’å¾Œã«ä¿å­˜
        }
      };
    }
    
    isCriticalEvent(eventType, additionalData) {
      return (
        eventType.includes('session_end') ||
        eventType.includes('video_end') ||
        eventType.includes('question') ||
        eventType.includes('answer') ||
        (eventType.includes('score_change') && Math.abs(additionalData?.scoreChange || 0) >= 10)
      );
    }
    
    setupExitHandlers() {
      let isExiting = false;
      
      const saveOnExit = () => {
        if (isExiting) return; // é‡è¤‡å®Ÿè¡Œã‚’é˜²ã
        isExiting = true;
        
        this.addTimestamp('session_end', 'å­¦ç¿’ã‚»ãƒƒã‚·ãƒ§ãƒ³çµ‚äº†');
        
        // sendBeaconã§ã®ç¢ºå®Ÿãªä¿å­˜ã‚’è©¦è¡Œ
        this.saveSessionToServer(true);
        
        // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ã¨ã—ã¦åŒæœŸä¿å­˜ã‚‚å®Ÿè¡Œ
        this.saveSessionToServerSync();
        
        // localStorageã«ã‚‚ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä¿å­˜
        try {
          // æ­£ã—ã„å‹•ç”»IDã®å–å¾—
          const pathParts = window.location.pathname.split('/');
          const videoId = pathParts[pathParts.length - 2];
          
          const backupData = {
            sessionStartTime: this.sessionStartTime,
            sessionEndTime: Date.now(),
            timestampLog: this.timestampLog,
            finalScore: this.score,
            videoId: videoId,
            saved: false // ã‚µãƒ¼ãƒãƒ¼ä¿å­˜æˆåŠŸãƒ•ãƒ©ã‚°
          };
          localStorage.setItem('pendingSessionData', JSON.stringify(backupData));
          localStorage.setItem('lastTimestampLog', JSON.stringify(backupData));
        } catch (e) {
          console.warn('localStorageã¸ã®ä¿å­˜ã«å¤±æ•—:', e);
        }
      };
      
      // è¤‡æ•°ã®ã‚¤ãƒ™ãƒ³ãƒˆã§é›¢è„±ã‚’æ¤œçŸ¥
      window.addEventListener('beforeunload', saveOnExit);
      window.addEventListener('unload', saveOnExit);
      window.addEventListener('pagehide', saveOnExit);
      
      // ãƒ–ãƒ©ã‚¦ã‚¶ã‚¿ãƒ–ã®éè¡¨ç¤ºåŒ–ã‚’æ¤œçŸ¥
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'hidden') {
          this.saveSessionToServer(); // éåŒæœŸä¿å­˜
        }
      });
      
      // ãƒ–ãƒ©ã‚¦ã‚¶ãƒ•ã‚©ãƒ¼ã‚«ã‚¹å–ªå¤±ã‚’æ¤œçŸ¥
      window.addEventListener('blur', () => {
        this.saveSessionToServer(); // éåŒæœŸä¿å­˜
      });
      
      // å®šæœŸçš„ãªã€Œç”Ÿå­˜ç¢ºèªã€ä¿å­˜
      setInterval(() => {
        this.saveSessionToServer();
      }, 30000); // 30ç§’é–“éš”
    }
    
    saveSessionToServerSync() {
      // åŒæœŸçš„ãªXHRè¦æ±‚ï¼ˆãƒšãƒ¼ã‚¸é›¢è„±æ™‚ç”¨ï¼‰
      try {
        const data = this.prepareSessionData();
        // æ­£ã—ã„å‹•ç”»IDã®å–å¾—
        const pathParts = window.location.pathname.split('/');
        const videoId = pathParts[pathParts.length - 2];
        
        const xhr = new XMLHttpRequest();
        xhr.open('POST', `/videos/${videoId}/management/save_session`, false); // åŒæœŸ
        xhr.setRequestHeader('Content-Type', 'application/json');
        xhr.setRequestHeader('X-CSRF-Token', document.querySelector('meta[name="csrf-token"]').content);
        
        xhr.send(JSON.stringify({ session_data: JSON.stringify(data) }));
        
        if (xhr.status === 200) {
          console.log('ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’åŒæœŸä¿å­˜ã—ã¾ã—ãŸ');
          // ä¿å­˜æˆåŠŸã‚’localStorageã«è¨˜éŒ²
          const pendingData = localStorage.getItem('pendingSessionData');
          if (pendingData) {
            const parsed = JSON.parse(pendingData);
            parsed.saved = true;
            localStorage.setItem('pendingSessionData', JSON.stringify(parsed));
          }
        }
      } catch (error) {
        console.error('åŒæœŸä¿å­˜ã‚¨ãƒ©ãƒ¼:', error);
      }
    }
    
    // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«æœªä¿å­˜ãƒ‡ãƒ¼ã‚¿ã‚’ãƒã‚§ãƒƒã‚¯
    checkPendingSessionData() {
      try {
        const pendingData = localStorage.getItem('pendingSessionData');
        if (pendingData) {
          const data = JSON.parse(pendingData);
          if (!data.saved && data.timestampLog && data.timestampLog.length > 0) {
            // æœªä¿å­˜ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆã€ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡
            console.log('æœªä¿å­˜ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ãƒ‡ãƒ¼ã‚¿ã‚’ç™ºè¦‹ã€ã‚µãƒ¼ãƒãƒ¼ã«é€ä¿¡ä¸­...');
            
            // æ­£ã—ã„å‹•ç”»IDã®å–å¾—
            const pathParts = window.location.pathname.split('/');
            const currentVideoId = pathParts[pathParts.length - 2];
            if (data.videoId === currentVideoId) {
              fetch(`/videos/${currentVideoId}/management/save_session`, {
                method: 'POST',
                headers: {
                  'Content-Type': 'application/json',
                  'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
                },
                body: JSON.stringify({ session_data: JSON.stringify({
                  sessionInfo: {
                    startTime: data.sessionStartTime,
                    endTime: data.sessionEndTime,
                    totalDuration: (data.sessionEndTime - data.sessionStartTime) / 1000,
                    videoId: data.videoId
                  },
                  timestampLog: data.timestampLog,
                  finalScore: data.finalScore
                })})
              })
              .then(response => response.json())
              .then(result => {
                if (result.success) {
                  console.log('æœªä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®å¾©æ—§ã«æˆåŠŸ:', result.session_id);
                  localStorage.removeItem('pendingSessionData');
                }
              })
              .catch(error => {
                console.error('æœªä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®å¾©æ—§ã«å¤±æ•—:', error);
              });
            }
          } else {
            // æ—¢ã«ä¿å­˜æ¸ˆã¿ã®å ´åˆã¯å‰Šé™¤
            localStorage.removeItem('pendingSessionData');
          }
        }
      } catch (e) {
        console.warn('æœªä¿å­˜ãƒ‡ãƒ¼ã‚¿ã®ãƒã‚§ãƒƒã‚¯ã§ã‚¨ãƒ©ãƒ¼:', e);
      }
    }
    
    // ã‚¹ã‚³ã‚¢è¨­å®šé–¢é€£ã®ãƒ¡ã‚½ãƒƒãƒ‰
    initializeSettingsPanel() {
      // è¨­å®šå€¤ã‚’å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«åæ˜ 
      this.updateSettingsUI();
      
      // è¨­å®šé©ç”¨ãƒœã‚¿ãƒ³
      const applyBtn = document.getElementById('apply-settings');
      if (applyBtn) {
        applyBtn.addEventListener('click', () => {
          this.applySettings();
        });
      }
      
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå¾©å…ƒãƒœã‚¿ãƒ³
      const resetBtn = document.getElementById('reset-settings');
      if (resetBtn) {
        resetBtn.addEventListener('click', () => {
          if (confirm('è¨­å®šã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«æˆ»ã—ã¾ã™ã‹ï¼Ÿ')) {
            this.resetToDefaultSettings();
          }
        });
      }
      
      // ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³
      const exportBtn = document.getElementById('export-settings');
      if (exportBtn) {
        exportBtn.addEventListener('click', () => {
          this.exportSettings();
        });
      }
      
      // ã‚¤ãƒ³ãƒãƒ¼ãƒˆãƒœã‚¿ãƒ³
      const importBtn = document.getElementById('import-settings');
      const importFile = document.getElementById('import-file');
      if (importBtn && importFile) {
        importBtn.addEventListener('click', () => {
          importFile.click();
        });
        
        importFile.addEventListener('change', (e) => {
          if (e.target.files.length > 0) {
            this.importSettings(e.target.files[0]);
          }
        });
      }
    }
    
    updateSettingsUI() {
      // å„è¨­å®šå€¤ã‚’å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã«åæ˜ 
      const settings = this.scoreSettings;
      
      Object.keys(settings).forEach(key => {
        const kebabKey = key.replace(/([A-Z])/g, '-$1').toLowerCase();
        const element = document.getElementById(kebabKey);
        if (element) {
          element.value = settings[key];
        }
      });
    }
    
    applySettings() {
      // å…¥åŠ›ãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ã‹ã‚‰è¨­å®šå€¤ã‚’èª­ã¿å–ã£ã¦é©ç”¨
      const elements = {
        'face-not-detected-penalty': 'faceNotDetectedPenalty',
        'movement-stop-penalty': 'movementStopPenalty',
        'response-delay-penalty': 'responseDelayPenalty',
        'center-gaze-bonus': 'centerGazeBonus',
        'question-confirm-bonus': 'questionConfirmBonus',
        'quick-response-bonus': 'quickResponseBonus',
        'note-input-bonus': 'noteInputBonus',
        'front-facing-bonus': 'frontFacingBonus',
        'movement-stop-threshold': 'movementStopThreshold',
        'response-delay-threshold': 'responseDelayThreshold',
        'quick-response-threshold': 'quickResponseThreshold',
        'front-facing-interval': 'frontFacingInterval',
        'center-gaze-interval': 'centerGazeInterval',
        'center-gaze-threshold': 'centerGazeThreshold',
        'gaze-velocity-threshold': 'gazeVelocityThreshold'
      };
      
      Object.keys(elements).forEach(elementId => {
        const element = document.getElementById(elementId);
        const settingKey = elements[elementId];
        
        if (element && settingKey in this.scoreSettings) {
          const value = parseFloat(element.value);
          if (!isNaN(value)) {
            this.scoreSettings[settingKey] = value;
          }
        }
      });
      
      // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨˜éŒ²
      this.addTimestamp('settings_apply', 'è¨­å®šå¤‰æ›´é©ç”¨');
      
      alert('è¨­å®šãŒé©ç”¨ã•ã‚Œã¾ã—ãŸ');
    }
    
    resetToDefaultSettings() {
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«æˆ»ã™
      this.scoreSettings = {
        faceNotDetectedPenalty: 2,
        movementStopPenalty: 1,
        responseDelayPenalty: 1,
        centerGazeBonus: 0.5,
        questionConfirmBonus: 5,
        quickResponseBonus: 3,
        noteInputBonus: 3,
        frontFacingBonus: 1,
        movementStopThreshold: 10,
        responseDelayThreshold: 30,
        quickResponseThreshold: 5,
        questionConfirmWindow: 3,
        frontFacingInterval: 5000,
        centerGazeInterval: 3000,
        gazeVelocityThreshold: 10,
        centerGazeThreshold: 15
      };
      
      this.updateSettingsUI();
      this.addTimestamp('settings_reset', 'è¨­å®šã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«å¾©å…ƒ');
      alert('è¨­å®šã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆå€¤ã«æˆ»ã—ã¾ã—ãŸ');
    }
    
    exportSettings() {
      const data = {
        timestamp: new Date().toISOString(),
        settings: this.scoreSettings
      };
      
      const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = `concentration-settings-${new Date().toISOString().slice(0, 10)}.json`;
      document.body.appendChild(a);
      a.click();
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
      
      this.addTimestamp('settings_export', 'è¨­å®šã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆ');
    }
    
    importSettings(file) {
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const data = JSON.parse(e.target.result);
          if (data.settings && typeof data.settings === 'object') {
            this.scoreSettings = { ...this.scoreSettings, ...data.settings };
            this.updateSettingsUI();
            this.addTimestamp('settings_import', 'è¨­å®šã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆ');
            alert('è¨­å®šã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ');
          } else {
            alert('ç„¡åŠ¹ãªè¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã§ã™');
          }
        } catch (error) {
          alert('è¨­å®šãƒ•ã‚¡ã‚¤ãƒ«ã®èª­ã¿è¾¼ã¿ã«å¤±æ•—ã—ã¾ã—ãŸ: ' + error.message);
        }
      };
      reader.readAsText(file);
    }
    initializeSettingsPanel() {
      // è¨­å®šå€¤ã‚’UIã«åæ˜ 
      this.loadSettingsToUI();
      
      // ã‚¤ãƒ™ãƒ³ãƒˆãƒªã‚¹ãƒŠãƒ¼ã‚’è¨­å®š
      document.getElementById('apply-settings')?.addEventListener('click', () => {
        this.applySettingsFromUI();
      });
      
      document.getElementById('reset-settings')?.addEventListener('click', () => {
        this.resetSettingsToDefault();
      });
      
      document.getElementById('export-settings')?.addEventListener('click', () => {
        this.exportSettings();
      });
      
      document.getElementById('import-settings')?.addEventListener('click', () => {
        document.getElementById('import-file').click();
      });
      
      document.getElementById('import-file')?.addEventListener('change', (event) => {
        this.importSettings(event.target.files[0]);
      });
    }
    
    loadSettingsToUI() {
      const settings = this.scoreSettings;
      
      // å„è¨­å®šé …ç›®ã‚’UIã«åæ˜ 
      Object.keys(settings).forEach(key => {
        const element = document.getElementById(key.replace(/([A-Z])/g, '-$1').toLowerCase());
        if (element) {
          element.value = settings[key];
        }
      });
    }
    
    applySettingsFromUI() {
      try {
        // UIã‹ã‚‰è¨­å®šå€¤ã‚’å–å¾—ã—ã¦é©ç”¨
        const newSettings = {};
        
        Object.keys(this.scoreSettings).forEach(key => {
          const elementId = key.replace(/([A-Z])/g, '-$1').toLowerCase();
          const element = document.getElementById(elementId);
          if (element) {
            const value = parseFloat(element.value);
            if (!isNaN(value)) {
              newSettings[key] = value;
            }
          }
        });
        
        // è¨­å®šã‚’æ›´æ–°
        Object.assign(this.scoreSettings, newSettings);
        
        // æˆåŠŸãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’è¡¨ç¤º
        this.showSettingsMessage('è¨­å®šã‚’é©ç”¨ã—ã¾ã—ãŸ', 'success');
        
        console.log('ã‚¹ã‚³ã‚¢è¨­å®šãŒæ›´æ–°ã•ã‚Œã¾ã—ãŸ:', this.scoreSettings);
        
      } catch (error) {
        console.error('è¨­å®šã®é©ç”¨ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
        this.showSettingsMessage('è¨­å®šã®é©ç”¨ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
      }
    }
    
    resetSettingsToDefault() {
      // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆè¨­å®š
      const defaultSettings = {
        faceNotDetectedPenalty: 2,
        movementStopPenalty: 1,
        responseDelayPenalty: 1,
        centerGazeBonus: 0.5,
        questionConfirmBonus: 5,
        quickResponseBonus: 3,
        noteInputBonus: 3,
        frontFacingBonus: 1,
        movementStopThreshold: 10,
        responseDelayThreshold: 30,
        quickResponseThreshold: 5,
        questionConfirmWindow: 3,
        frontFacingInterval: 5000,
        centerGazeInterval: 3000,
        movementDetectionThreshold: 10,
        gazeVelocityThreshold: 10,
        centerGazeThreshold: 10
      };
      
      // è¨­å®šã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã™
      this.scoreSettings = { ...defaultSettings };
      
      // UIã«ã‚‚åæ˜ 
      this.loadSettingsToUI();
      
      this.showSettingsMessage('è¨­å®šã‚’ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã«æˆ»ã—ã¾ã—ãŸ', 'info');
    }
    
    exportSettings() {
      try {
        const settingsJson = JSON.stringify(this.scoreSettings, null, 2);
        const blob = new Blob([settingsJson], { type: 'application/json' });
        const url = URL.createObjectURL(blob);
        
        const a = document.createElement('a');
        a.href = url;
        a.download = 'concentration_settings.json';
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        this.showSettingsMessage('è¨­å®šã‚’ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
        
      } catch (error) {
        console.error('è¨­å®šã®ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
        this.showSettingsMessage('ã‚¨ã‚¯ã‚¹ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
      }
    }
    
    importSettings(file) {
      if (!file) return;
      
      const reader = new FileReader();
      reader.onload = (e) => {
        try {
          const importedSettings = JSON.parse(e.target.result);
          
          // è¨­å®šã‚’æ¤œè¨¼
          const validKeys = Object.keys(this.scoreSettings);
          const filteredSettings = {};
          
          Object.keys(importedSettings).forEach(key => {
            if (validKeys.includes(key) && typeof importedSettings[key] === 'number') {
              filteredSettings[key] = importedSettings[key];
            }
          });
          
          // è¨­å®šã‚’é©ç”¨
          Object.assign(this.scoreSettings, filteredSettings);
          
          // UIã«åæ˜ 
          this.loadSettingsToUI();
          
          this.showSettingsMessage('è¨­å®šã‚’ã‚¤ãƒ³ãƒãƒ¼ãƒˆã—ã¾ã—ãŸ', 'success');
          
        } catch (error) {
          console.error('è¨­å®šã®ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
          this.showSettingsMessage('ã‚¤ãƒ³ãƒãƒ¼ãƒˆä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ', 'error');
        }
      };
      
      reader.readAsText(file);
    }
    
    showSettingsMessage(message, type) {
      // ç°¡æ˜“çš„ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
      const existingMessage = document.querySelector('.settings-message');
      if (existingMessage) {
        existingMessage.remove();
      }
      
      const messageEl = document.createElement('div');
      messageEl.className = `settings-message settings-message-${type}`;
      messageEl.textContent = message;
      messageEl.style.cssText = `
        position: absolute;
        top: 10px;
        right: 10px;
        padding: 8px 12px;
        border-radius: 4px;
        font-size: 12px;
        z-index: 1000;
        ${type === 'success' ? 'background: #28a745; color: white;' : ''}
        ${type === 'error' ? 'background: #dc3545; color: white;' : ''}
        ${type === 'info' ? 'background: #17a2b8; color: white;' : ''}
      `;
      
      document.body.appendChild(messageEl);
      
      // 3ç§’å¾Œã«è‡ªå‹•ã§å‰Šé™¤
      setTimeout(() => {
        if (messageEl.parentNode) {
          messageEl.parentNode.removeChild(messageEl);
        }
      }, 3000);
    }
  }
  
  // é›†ä¸­åº¦ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã‚’åˆæœŸåŒ–
  const concentrationTracker = new ConcentrationTracker();
  
  // JSONãƒ‡ãƒ¼ã‚¿ã®ç¢ºèª
  let rawQuestionData;
  try {
    rawQuestionData = <%= raw @questions.to_json(include: :options) %>;
    console.log('ç”Ÿã®è³ªå•ãƒ‡ãƒ¼ã‚¿ã‚’å–å¾—ã—ã¾ã—ãŸ');
  } catch (e) {
    console.error('è³ªå•ãƒ‡ãƒ¼ã‚¿ã®è§£æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', e);
    rawQuestionData = [];
  }
  
  // Initialize questions with a 'shown' property to track which ones have been displayed
  const questions = (rawQuestionData || []).map(q => ({...q, shown: false}));
  console.log('è³ªå•ãƒ‡ãƒ¼ã‚¿:', questions);
  console.log('è³ªå•æ•°:', questions.length);
  
  // è³ªå•ãƒ‡ãƒ¼ã‚¿ã®è©³ç´°ãƒ­ã‚°
  questions.forEach((q, index) => {
    console.log(`è³ªå•${index + 1}:`, {
      id: q.id,
      content: q.content,
      time_position: q.time_position,
      question_type: q.question_type
    });
  });
  
  const waitingMessage = document.getElementById('waiting-message');
  const questionDisplay = document.getElementById('question-display');
  const questionText = document.getElementById('question-text');
  const questionIndicator = document.getElementById('question-indicator');
  
  const trueFalseForm = document.getElementById('true-false-form');
  const multipleChoiceForm = document.getElementById('multiple-choice-form');
  const freeResponseForm = document.getElementById('free-response-form');
  const mcOptions = document.getElementById('mc-options');
  
  const tfSubmit = document.getElementById('tf-submit');
  const mcSubmit = document.getElementById('mc-submit');
  const frSubmit = document.getElementById('fr-submit');
  const resultMessage = document.getElementById('result-message');
  
  const noteTextarea = document.getElementById('note-textarea');
  const saveNoteBtn = document.getElementById('save-note-btn');
  const savedNotes = document.getElementById('saved-notes');
  
  // ãƒ¡ãƒ¢å…¥åŠ›æ™‚ã®ã‚¤ãƒ™ãƒ³ãƒˆè¿½åŠ 
  let noteInputTimer;
  noteTextarea.addEventListener('input', function() {
    // é€£ç¶šã—ãŸå…¥åŠ›ã‚’ã¾ã¨ã‚ã‚‹ãŸã‚ã«500mså¾…ã¤
    clearTimeout(noteInputTimer);
    noteInputTimer = setTimeout(() => {
      concentrationTracker.onNoteInput();
    }, 500);
  });
  
  let activeQuestion = null;
  let videoCheckInterval;
  let questionIndicatorTimeout;
  let questionStartTime = null; // è³ªå•è¡¨ç¤ºé–‹å§‹æ™‚é–“ã‚’è¨˜éŒ²

  if (videoPlayer) {
    // å‹•ç”»ã®èª­ã¿è¾¼ã¿çŠ¶æ…‹ã‚’ãƒ‡ãƒãƒƒã‚°ãƒ­ã‚°ã§ç¢ºèª
    console.log('åˆæœŸå‹•ç”»çŠ¶æ…‹:', {
      readyState: videoPlayer.readyState,
      paused: videoPlayer.paused,
      duration: videoPlayer.duration,
      currentSrc: videoPlayer.currentSrc
    });
    
    // å‹•ç”»ã®èª­ã¿è¾¼ã¿å®Œäº†ã‚’å¾…ã¤
    videoPlayer.addEventListener('loadedmetadata', function() {
      console.log('å‹•ç”»ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿å®Œäº†');
    });
    
    // å‹•ç”»ã®å†ç”Ÿå¯èƒ½çŠ¶æ…‹ã‚’å¾…ã¤
    videoPlayer.addEventListener('canplay', function() {
      console.log('å‹•ç”»å†ç”Ÿå¯èƒ½:', {
        readyState: videoPlayer.readyState,
        duration: videoPlayer.duration
      });
      
      // å‹•ç”»ãŒå†ç”Ÿå¯èƒ½ã«ãªã£ãŸã‚‰å•é¡Œãƒã‚§ãƒƒã‚¯é–‹å§‹
      if (!videoCheckInterval) {
        console.log('å•é¡Œãƒã‚§ãƒƒã‚¯ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹');
        videoCheckInterval = setInterval(checkVideoTime, 1000);
      }
    });
    
    // å‹•ç”»ã®æ™‚é–“æ›´æ–°ã‚¤ãƒ™ãƒ³ãƒˆã§å•é¡Œã‚’ãƒã‚§ãƒƒã‚¯ï¼ˆã‚ˆã‚Šé »ç¹ãªãƒã‚§ãƒƒã‚¯ï¼‰
    videoPlayer.addEventListener('timeupdate', function() {
      checkVideoTime();
    });
    
    // å†ç”Ÿé–‹å§‹æ™‚ã®è¿½åŠ ãƒã‚§ãƒƒã‚¯
    videoPlayer.addEventListener('play', function() {
      console.log('å‹•ç”»å†ç”Ÿé–‹å§‹');
      checkVideoTime(); // å³åº§ã«ãƒã‚§ãƒƒã‚¯
    });
    
    // å®‰å…¨ç­–ã¨ã—ã¦ã€DOMContentLoadedã®å¾Œã«å°‘ã—é…å»¶ã•ã›ã¦å•é¡Œãƒã‚§ãƒƒã‚¯ã‚’é–‹å§‹
    setTimeout(() => {
      if (!videoCheckInterval && videoPlayer.readyState >= 2) {
        console.log('é…å»¶å•é¡Œãƒã‚§ãƒƒã‚¯ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹');
        videoCheckInterval = setInterval(checkVideoTime, 1000);
      }
    }, 1000);
    
    // Reset questions when video is seeked
    videoPlayer.addEventListener('seeked', function() {
      // Only reset questions if seeking backwards
      const currentTime = videoPlayer.currentTime;
      console.log('ã‚·ãƒ¼ã‚¯ä½ç½®å¤‰æ›´:', currentTime);
      
      for (const question of questions) {
        if (question.shown && question.time_position > currentTime) {
          console.log(`è³ªå•ãƒªã‚»ãƒƒãƒˆ: ${question.content}`);
          question.shown = false;
        }
      }
      
      // Hide the indicator until the next check
      questionIndicator.style.display = 'none';
      if (questionIndicatorTimeout) {
        clearTimeout(questionIndicatorTimeout);
      }
    });
    
    // Reset all questions when video is restarted
    videoPlayer.addEventListener('ended', function() {
      for (const question of questions) {
        question.shown = false;
      }
    });
    
    // åˆå›ã®å•é¡Œãƒã‚§ãƒƒã‚¯ã‚’å‹•ç”»ã¨è³ªå•ãƒ‡ãƒ¼ã‚¿ã®ä¸¡æ–¹ãŒæƒã£ãŸã‚¿ã‚¤ãƒŸãƒ³ã‚°ã§å®Ÿè¡Œ
    let initialQuestionCheckDone = false;
    function tryInitialQuestionCheck() {
      if (!initialQuestionCheckDone && videoPlayer.readyState >= 2 && questions.length > 0) {
        console.log('åˆå›ã®å•é¡Œãƒã‚§ãƒƒã‚¯ã‚’å¼·åˆ¶å®Ÿè¡Œã—ã¾ã™');
        checkVideoTime();
        initialQuestionCheckDone = true;
      }
    }
    
    document.addEventListener('DOMContentLoaded', tryInitialQuestionCheck);
    videoPlayer.addEventListener('loadedmetadata', tryInitialQuestionCheck);
    videoPlayer.addEventListener('canplay', tryInitialQuestionCheck);
    
    function checkVideoTime() {
      // å‹•ç”»ãŒèª­ã¿è¾¼ã¾ã‚Œã¦ã„ãªã„å ´åˆã¯ä½•ã‚‚ã—ãªã„
      if (videoPlayer.readyState < 2) {
        console.log('å‹•ç”»ãŒã¾ã ååˆ†ã«èª­ã¿è¾¼ã¾ã‚Œã¦ã„ã¾ã›ã‚“:', videoPlayer.readyState);
        return;
      }
      
      const currentTime = videoPlayer.currentTime;
      
      // å†ç”Ÿä¸­ã¾ãŸã¯ãƒã‚§ãƒƒã‚¯ã™ã‚‹å¿…è¦ãŒã‚ã‚‹å ´åˆ
      if (!videoPlayer.paused || activeQuestion !== null) {
        console.log('ç¾åœ¨ã®å†ç”Ÿä½ç½®:', currentTime);
        
        // Check for upcoming questions
        const upcomingQuestionWindow = 5; // Show indicator 5 seconds before question
        
        let hasUpcomingQuestion = false;
        for (let i = 0; i < questions.length; i++) {
          const question = questions[i];
          
          // ãƒ‡ãƒãƒƒã‚°ç”¨ï¼šã™ã¹ã¦ã®è³ªå•ã®çŠ¶æ…‹ã‚’å®šæœŸçš„ã«ãƒã‚§ãƒƒã‚¯
          if (Math.floor(currentTime) % 5 === 0) {
            console.log(`è³ªå•${i+1}:`, question.content, 'ä½ç½®:', question.time_position, 'è¡¨ç¤ºæ¸ˆã¿:', question.shown);
          }
          
          // Check if there's a question coming up soon but not yet shown
          if (currentTime < question.time_position && 
              currentTime >= question.time_position - upcomingQuestionWindow && 
              !question.shown) {
            hasUpcomingQuestion = true;
            console.log('é–“ã‚‚ãªãå•é¡Œ:', question.content);
            // Show indicator if not already showing
            if (questionIndicator.style.display !== 'block') {
              questionIndicator.style.display = 'block';
              
              // Clear any existing timeout
              if (questionIndicatorTimeout) {
                clearTimeout(questionIndicatorTimeout);
              }
            }
          }
          
          // If the current time is past or equal to the question time and within a larger window (2s)
          // and no question is currently active
          if (currentTime >= question.time_position && 
              currentTime <= question.time_position + 2.0 && 
              activeQuestion === null && 
              !question.shown) {
            console.log('å•é¡Œæ¤œå‡º:', question);
            console.log('ç¾åœ¨ã®æ™‚é–“:', currentTime, 'å•é¡Œæ™‚é–“:', question.time_position);
            console.log('æ™‚é–“å·®:', currentTime - question.time_position);
            // Mark this question as shown so it doesn't appear again
            question.shown = true;
            // Hide the indicator
            questionIndicator.style.display = 'none';
            if (questionIndicatorTimeout) {
              clearTimeout(questionIndicatorTimeout);
            }
            try {
              console.log('showQuestioné–¢æ•°ã‚’å‘¼ã³å‡ºã—ã¾ã™');
              showQuestion(question);
              videoPlayer.pause();
              console.log('å‹•ç”»ã‚’ä¸€æ™‚åœæ­¢ã—ã¾ã—ãŸ');
            } catch (error) {
              console.error('å•é¡Œè¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
              // ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ãŸå ´åˆã¯shownãƒ•ãƒ©ã‚°ã‚’ãƒªã‚»ãƒƒãƒˆ
              question.shown = false;
            }
            break;
          }
        }
        
        // If no upcoming questions, hide the indicator
        if (!hasUpcomingQuestion && questionIndicator.style.display === 'block') {
          // Set a small delay before hiding to prevent flickering
          questionIndicatorTimeout = setTimeout(() => {
            questionIndicator.style.display = 'none';
          }, 500);
        }
      }
    }
    
    function showQuestion(question) {
      console.log('showQuestioné–¢æ•°é–‹å§‹:', question);
      
      // å•é¡Œè¡¨ç¤ºé–‹å§‹æ™‚é–“ã‚’è¨˜éŒ²
      questionStartTime = Date.now();
      
      // é›†ä¸­åº¦ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã«å•é¡Œè¡¨ç¤ºã‚’é€šçŸ¥
      if (window.concentrationTracker) {
        concentrationTracker.onQuestionDisplayed();
      } else {
        console.warn('ConcentrationTrackerãŒåˆ©ç”¨ã§ãã¾ã›ã‚“');
      }
      
      // å•é¡Œãƒ‡ãƒ¼ã‚¿ã®æ¤œè¨¼
      if (!question || !question.content) {
        console.error('å•é¡Œãƒ‡ãƒ¼ã‚¿ãŒä¸æ­£ã§ã™:', question);
        return;
      }
      
      console.log('å•é¡Œãƒ‡ãƒ¼ã‚¿æ¤œè¨¼å®Œäº†');
      
      activeQuestion = question;
      
      try {
        // UIè¦ç´ ã®å­˜åœ¨ç¢ºèª
        if (!waitingMessage) {
          console.error('waitingMessageè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
          return;
        }
        if (!questionDisplay) {
          console.error('questionDisplayè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
          return;
        }
        if (!questionText) {
          console.error('questionTextè¦ç´ ãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“');
          return;
        }
        
        console.log('UIè¦ç´ ã®å­˜åœ¨ç¢ºèªå®Œäº†');
        
        // Hide waiting message, show question
        waitingMessage.style.display = 'none';
        questionDisplay.style.display = 'block';
        
        console.log('UIè¡¨ç¤ºåˆ‡ã‚Šæ›¿ãˆå®Œäº†');
        
        // Set question text with timestamp
        const timeFormatted = formatTimePosition(question.time_position || 0);
        console.log('ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆæ¸ˆã¿æ™‚é–“:', timeFormatted);
        console.log('å•é¡Œå†…å®¹:', question.content);
        
        // å•é¡Œæ–‡ã‚’è¡¨ç¤º
        questionText.textContent = ''; // ä¸€æ—¦ã‚¯ãƒªã‚¢
        
        const timestampDiv = document.createElement('div');
        timestampDiv.className = 'question-timestamp';
        timestampDiv.textContent = timeFormatted;
        questionText.appendChild(timestampDiv);
        
        const contentDiv = document.createElement('div');
        contentDiv.className = 'question-content-text';
        contentDiv.textContent = question.content;
        questionText.appendChild(contentDiv);
        
        // Reset previous result message
        resultMessage.style.display = 'none';
        resultMessage.className = 'result-message';
        
        // Show appropriate form based on question type
        trueFalseForm.style.display = 'none';
        multipleChoiceForm.style.display = 'none';
        freeResponseForm.style.display = 'none';
        
        if (question.question_type === 'true_false') {
          trueFalseForm.style.display = 'block';
          // Reset selection
          const radios = trueFalseForm.querySelectorAll('input[type="radio"]');
          radios.forEach(radio => radio.checked = false);
        } 
        else if (question.question_type === 'multiple_choice') {
          multipleChoiceForm.style.display = 'block';
          
          // Clear previous options
          mcOptions.innerHTML = '';
          
          // Add new options
          if (question.options && question.options.length > 0) {
            question.options.forEach((option, index) => {
              if (!option || !option.content) return;
              
              const label = document.createElement('label');
              label.className = 'option-label';
              
              const input = document.createElement('input');
              input.type = 'radio';
              input.name = 'mc-answer';
              input.value = option.id;
              
              label.appendChild(input);
              label.appendChild(document.createTextNode(' ' + option.content));
              mcOptions.appendChild(label);
            });
          } else {
            console.error('é¸æŠè‚¢ãŒã‚ã‚Šã¾ã›ã‚“:', question);
          }
        } 
        else if (question.question_type === 'free_response') {
          freeResponseForm.style.display = 'block';
          document.getElementById('free-response-answer').value = '';
        }
      } catch (error) {
        console.error('å•é¡Œè¡¨ç¤ºä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸ:', error);
      }
    }
    
    // Helper function to format time position
    function formatTimePosition(timeInSeconds) {
      const minutes = Math.floor(timeInSeconds / 60);
      const seconds = Math.floor(timeInSeconds % 60);
      return `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
    }
    
    // Handle true/false submission
    tfSubmit.addEventListener('click', function() {
      const selectedAnswer = document.querySelector('input[name="tf-answer"]:checked');
      
      if (selectedAnswer && activeQuestion) {
        // é›†ä¸­åº¦ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã«å›ç­”é–‹å§‹ã‚’é€šçŸ¥
        concentrationTracker.onResponseStarted();
        submitAnswer(selectedAnswer.value, null);
      } else {
        alert('å›ç­”ã‚’é¸æŠã—ã¦ãã ã•ã„');
      }
    });
    
    // Handle multiple choice submission
    mcSubmit.addEventListener('click', function() {
      const selectedOption = document.querySelector('input[name="mc-answer"]:checked');
      
      if (selectedOption && activeQuestion) {
        // é›†ä¸­åº¦ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã«å›ç­”é–‹å§‹ã‚’é€šçŸ¥
        concentrationTracker.onResponseStarted();
        const optionId = selectedOption.value;
        submitAnswer(null, optionId);
      } else {
        alert('å›ç­”ã‚’é¸æŠã—ã¦ãã ã•ã„');
      }
    });
    
    // Handle free response submission
    frSubmit.addEventListener('click', function() {
      const answer = document.getElementById('free-response-answer').value.trim();
      
      // è¨˜è¿°å•é¡Œã§ã¯ç©ºæ¬„ã‚‚æœ‰åŠ¹ãªå›ç­”ã¨ã—ã¦å—ã‘ä»˜ã‘ã‚‹
      if (activeQuestion) {
        // é›†ä¸­åº¦ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã«å›ç­”é–‹å§‹ã‚’é€šçŸ¥
        concentrationTracker.onResponseStarted();
        // ç©ºæ¬„ã§ã‚‚é€ä¿¡å¯èƒ½ã«å¤‰æ›´
        submitAnswer(answer, null);
      } else {
        alert('å•é¡ŒãŒè¡¨ç¤ºã•ã‚Œã¦ã„ã¾ã›ã‚“');
      }
    });
    
    function submitAnswer(userAnswer, optionId) {
      // å›ç­”æ™‚é–“ã‚’è¨ˆç®—ï¼ˆãƒŸãƒªç§’ï¼‰
      const responseTime = questionStartTime ? Date.now() - questionStartTime : 0;
      
      // ã‚¿ã‚¤ãƒ ã‚¹ã‚¿ãƒ³ãƒ—è¨˜éŒ²
      if (window.concentrationTracker) {
        window.concentrationTracker.addTimestamp('answer_submit', 'å›ç­”é€ä¿¡', {
          userAnswer: userAnswer,
          optionId: optionId,
          responseTimeMs: responseTime,
          responseTimeS: responseTime / 1000
        });
      }
      
      const formData = new FormData();
      
      if (userAnswer) {
        formData.append('user_response[user_answer]', userAnswer);
      }
      
      if (optionId) {
        formData.append('option_id', optionId);
      }
      
      // å›ç­”æ™‚é–“ã‚’è¿½åŠ 
      formData.append('user_response[response_time]', responseTime.toString());
      
      // CSRFãƒˆãƒ¼ã‚¯ãƒ³ã‚’å–å¾—
      const csrfToken = document.querySelector('meta[name="csrf-token"]');
      const headers = {
        'Accept': 'application/json'
      };
      if (csrfToken) {
        headers['X-CSRF-Token'] = csrfToken.content;
      }
      
      // Store the current question for reference after the request
      const currentQuestion = activeQuestion;
      
      // é€ä¿¡å‰ã«ãƒ‡ãƒãƒƒã‚°æƒ…å ±
      console.log('é€ä¿¡ãƒ‡ãƒ¼ã‚¿:', {
        url: `/videos/<%= @video.id %>/questions/${currentQuestion.id}/user_responses`,
        userAnswer: userAnswer,
        optionId: optionId
      });
      
      // Send response to the server
      fetch(`/videos/<%= @video.id %>/questions/${currentQuestion.id}/user_responses`, {
        method: 'POST',
        body: formData,
        headers: headers
      })
      .then(response => {
        console.log('ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹:', response.status);
        console.log('ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼:', {
          contentType: response.headers.get('Content-Type'),
          accept: response.headers.get('Accept')
        });
        
        if (!response.ok) {
          // ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹ã®å ´åˆã€JSONã§è©³ç´°ã‚’å–å¾—
          const contentType = response.headers.get('Content-Type');
          if (contentType && contentType.includes('application/json')) {
            return response.json().then(errorData => {
              console.error('ã‚µãƒ¼ãƒãƒ¼ã‚¨ãƒ©ãƒ¼è©³ç´°:', errorData);
              const error = new Error(`Server error: ${response.status}`);
              error.response = response;
              error.data = errorData;
              throw error;
            });
          } else {
            return response.text().then(text => {
              console.error('ã‚¨ãƒ©ãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹:', text);
              const error = new Error(`Network response was not ok: ${response.status}`);
              error.response = response;
              throw error;
            });
          }
        }
        
        // Check if the response is JSON
        const contentType = response.headers.get('Content-Type');
        if (!contentType || !contentType.includes('application/json')) {
          return response.text().then(text => {
            console.error('äºˆæœŸã›ã¬ãƒ¬ã‚¹ãƒãƒ¼ã‚¹å½¢å¼:', contentType, text);
            throw new Error('Expected JSON response but got ' + contentType);
          });
        }
        
        return response.json();
      })
      .then(data => {
        console.log('ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹ãƒãƒ³ã‚¹:', data);
        
        // Display result
        resultMessage.style.display = 'block';
        
        let resultText = '';
        
        if (data.correct) {
          resultMessage.className = 'result-message correct';
          resultText = 'æ­£è§£ã§ã™ï¼';
          
          // è§£ç­”è¡¨ç¤ºè¨­å®šãŒæœ‰åŠ¹ãªå ´åˆã€æ­£è§£ã‚‚è¡¨ç¤º
          if (data.show_answer && data.correct_answer) {
            resultText += ` æ­£è§£: ${data.correct_answer}`;
          }
        } else {
          resultMessage.className = 'result-message incorrect';
          resultText = 'ä¸æ­£è§£ã§ã™ã€‚';
          
          // è§£ç­”è¡¨ç¤ºè¨­å®šãŒæœ‰åŠ¹ãªå ´åˆã®ã¿æ­£è§£ã‚’è¡¨ç¤º
          if (data.show_answer && data.correct_answer) {
            resultText += ` æ­£è§£: ${data.correct_answer}`;
          }
        }
        
        // å›ç­”æ™‚é–“ã‚’è¡¨ç¤º
        if (data.response_time) {
          resultText += ` (å›ç­”æ™‚é–“: ${data.response_time.toFixed(1)}ç§’)`;
        }
        
        resultMessage.textContent = resultText;
        
        // Reset active question after 3 seconds and resume video
        setTimeout(() => {
          activeQuestion = null;
          
          // ConcentrationTrackerã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°å¤‰æ•°ã‚‚ãƒªã‚»ãƒƒãƒˆ
          if (window.concentrationTracker) {
            window.concentrationTracker.questionDisplayTime = null;
            window.concentrationTracker.responseStartTime = null;
            window.concentrationTracker.responseProcessed = false;
          }
          
          waitingMessage.style.display = 'block';
          questionDisplay.style.display = 'none';
          videoPlayer.play();
        }, 3000);
      })
      .catch(error => {
        console.error('Error:', error);
        
        let errorMessage = 'å›ç­”ã®é€ä¿¡ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚';
        
        // ã‚µãƒ¼ãƒãƒ¼ã‹ã‚‰ã®ã‚¨ãƒ©ãƒ¼ãƒ‡ãƒ¼ã‚¿ãŒã‚ã‚‹å ´åˆ
        if (error.data) {
          console.error('Server error details:', error.data);
          
          if (error.data.errors && error.data.errors.length > 0) {
            errorMessage += '\nè©³ç´°: ' + error.data.errors.join(', ');
          }
          
          if (error.data.debug_info) {
            console.log('Debug info:', error.data.debug_info);
          }
        } else if (error.message) {
          errorMessage += '\nè©³ç´°: ' + error.message;
        }
        
        alert(errorMessage);
        
        // In case of error, still reset the question and continue playing
        setTimeout(() => {
          activeQuestion = null;
          
          // ConcentrationTrackerã®ã‚¿ã‚¤ãƒŸãƒ³ã‚°å¤‰æ•°ã‚‚ãƒªã‚»ãƒƒãƒˆ
          if (window.concentrationTracker) {
            window.concentrationTracker.questionDisplayTime = null;
            window.concentrationTracker.responseStartTime = null;
            window.concentrationTracker.responseProcessed = false;
          }
          
          waitingMessage.style.display = 'block';
          questionDisplay.style.display = 'none';
          videoPlayer.play();
        }, 1000);
      });
    }
    
    // Note system
    saveNoteBtn.addEventListener('click', function() {
      const noteContent = noteTextarea.value.trim();
      
      if (noteContent) {
        // é›†ä¸­åº¦ãƒˆãƒ©ãƒƒã‚«ãƒ¼ã«ãƒ¡ãƒ¢å…¥åŠ›ã‚’é€šçŸ¥
        concentrationTracker.onNoteInput();
        
        const formData = new FormData();
        formData.append('note[content]', noteContent);
        formData.append('note[time_position]', Math.floor(videoPlayer.currentTime));
        
        // Send note to the server
        fetch(`/videos/<%= @video.id %>/notes`, {
          method: 'POST',
          body: formData,
          headers: {
            'X-CSRF-Token': document.querySelector('meta[name="csrf-token"]').content
          }
        })
        .then(response => response.json())
        .then(data => {
          // Add the new note to the list
          const notesList = document.querySelector('.notes-list') || document.createElement('ul');
          
          if (!notesList.classList.contains('notes-list')) {
            notesList.className = 'notes-list';
            
            const heading = document.createElement('h4');
            heading.textContent = 'ä¿å­˜ã—ãŸãƒ¡ãƒ¢';
            
            savedNotes.innerHTML = '';
            savedNotes.appendChild(heading);
            savedNotes.appendChild(notesList);
          }
          
          const noteItem = document.createElement('li');
          noteItem.className = 'note-item';
          
          const noteTime = document.createElement('div');
          noteTime.className = 'note-time';
          
          const minutes = Math.floor(data.time_position / 60);
          const seconds = Math.floor(data.time_position % 60);
          noteTime.textContent = `${minutes.toString().padStart(2, '0')}:${seconds.toString().padStart(2, '0')}`;
          
          const noteText = document.createElement('div');
          noteText.className = 'note-text';
          noteText.textContent = data.content;
          
          noteItem.appendChild(noteTime);
          noteItem.appendChild(noteText);
          notesList.appendChild(noteItem);
          
          // Clear the textarea
          noteTextarea.value = '';
        })
        .catch(error => {
          console.error('Error:', error);
          alert('ãƒ¡ãƒ¢ã®ä¿å­˜ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
        });
      } else {
        alert('ãƒ¡ãƒ¢ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„');
      }
    });
    
    // Clean up interval when leaving the page
    window.addEventListener('beforeunload', function() {
      clearInterval(videoCheckInterval);
    });
  }
});
</script>
